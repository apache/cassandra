/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.cassandra.utils;

import java.io.File; // checkstyle: permit this import
import java.io.FileWriter; // checkstyle: permit this import
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ClassUtils;

import org.apache.cassandra.config.Config;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.GuardrailsOptions;
import org.apache.cassandra.config.registry.PropertyAccessorsWalker;

import static org.apache.cassandra.utils.ConstantFieldsGenerateUtil.addLicense;

/**
 * This class is used to generate constants class of provided class.
 */
public class AccessorWalkerGenerateUtil
{
    private static final String DESTINATION_PACKAGE = "org.apache.cassandra.config";
    private static final Pattern DOT_PATTERN = Pattern.compile("\\.");
    private static final Pattern DOLLAR_PATTERN = Pattern.compile("$", Pattern.LITERAL);
    private static final Class<?> CONFIG_CLASS = Config.class;
    private static final String CLASS_POSTFIX = "Walker";
    private static final String TAB = "    ";

    public static void main(String[] args) throws Exception
    {
        AccessorWalkerGenerateUtil generator = new AccessorWalkerGenerateUtil();

        generator.generateAndWrite(DatabaseDescriptor.class);
        generator.generateAndWrite(GuardrailsOptions.class);
    }

    private void generateAndWrite(Class<?> clazz) throws Exception
    {
        URL root = CONFIG_CLASS.getProtectionDomain().getCodeSource().getLocation();
        String project = Paths.get(root.toURI()).toFile().getParentFile().getParent(); // checkstyle: permit this invocation
        File configFieldsClass = Paths.get(project + "/src/java/",
                                           DOT_PATTERN.matcher(DESTINATION_PACKAGE).replaceAll("/"),
                                           "/",
                                           clazz.getSimpleName() + CLASS_POSTFIX + ".java").toFile();  // checkstyle: permit this invocation

        if (configFieldsClass.createNewFile())
            System.out.println("File created: " + configFieldsClass.getAbsolutePath());

        try (FileWriter writer = new FileWriter(configFieldsClass))
        {
            for (String line : getClassLines(clazz))
            {
                writer.write(line);
                writer.write('\n');
            }
        }
    }

    private List<String> getClassLines(Class<?> clazz)
    {
        List<String> code = new ArrayList<>();
        Set<Class<?>> types = new HashSet<>();
        types.add(PropertyAccessorsWalker.class);
        Arrays.stream(getConfigEditableFields())
              .map(Field::getType)
              .filter(t -> !ClassUtils.isPrimitiveOrWrapper(t))
              .forEach(types::add);

        String simpleName = clazz.getSimpleName();
        code.add("");
        code.add("package " + DESTINATION_PACKAGE + ';');
        code.add("");
        code.addAll(types.stream().map(this::generateImport).filter(Objects::nonNull).sorted().collect(Collectors.toList()));
        code.add("");
        code.add("/**");
        code.add("* This class is generated by {@link " + AccessorWalkerGenerateUtil.class.getCanonicalName() + "} on given {@link " + clazz.getSimpleName() + "} source class.");
        code.add("* It contains all the configuration property setters and getters that match the yaml property names in the {@code Config}");
        code.add("* and the type of the property fields. For example, a yaml property and its corresponding Config field has the name \"cdc_block_writes\"");
        code.add("* and the type - boolean, then we will look up for the setter method named setCdcBlockWrites to be in the given source class.");
        code.add(" * @see " + AccessorWalkerGenerateUtil.class.getName());
        code.add(" * @see " + clazz.getName());
        code.add(" */");
        code.add("public class " + simpleName + CLASS_POSTFIX + " implements PropertyAccessorsWalker");
        code.add("{");
        code.add(TAB + "private final " + simpleName + " source;");
        code.add("");
        code.add(TAB + "public " + simpleName + CLASS_POSTFIX + '(' + simpleName + " source)");
        code.add(TAB + '{');
        code.add(TAB + TAB + "this.source = source;");
        code.add(TAB + '}');
        code.add("");
        code.add(TAB + "@Override");
        code.add(TAB + "public void walk(PropertyAccessorsVisitor visitor)");
        code.add(TAB + '{');
        code.addAll(getVisitorLine(clazz));
        code.add(TAB + '}');
        code.add("}");
        addLicense(code);
        return code;
    }

    private Set<String> getVisitorLine(Class<?> clazz)
    {
        Set<String> code = new TreeSet<>();
        Set<Pair<String, Class<?>>> getMethods = Arrays.stream(clazz.getMethods())
                                                       .filter(m -> m.getParameterTypes().length == 0)
                                                       .filter(m -> m.getName().startsWith("get"))
                                                       .map(m -> new Pair<String, Class<?>>(m.getName().substring(3), m.getReturnType()))
                                                       .collect(Collectors.toSet());
        Set<Pair<String, Class<?>>> setMethods = Arrays.stream(clazz.getMethods())
                                                       .filter(m -> m.getParameterTypes().length == 1)
                                                       .filter(m -> m.getName().startsWith("set"))
                                                       .map(m -> new Pair<String, Class<?>>(m.getName().substring(3), m.getParameterTypes()[0]))
                                                       .collect(Collectors.toSet());

        for (Field f : getConfigEditableFields())
        {
            // Skip anonymous classes as field types.
            if (f.getType().getCanonicalName() == null)
                continue;

            Pair<String, Class<?>> pair = new Pair<>(convertToCamelCase(f.getName()), f.getType());
            if (getMethods.contains(pair) || setMethods.contains(pair))
            {
                code.add(TAB + TAB + "visitor.visit(ConfigFields." + f.getName().toUpperCase() + ", " + getType(f.getType()) + ", " +
                         getAccessorOrNull(clazz, setMethods.contains(pair) ? "set" + pair.left : null) + ", " +
                         getAccessorOrNull(clazz, getMethods.contains(pair) ? "get" + pair.left : null) + ");");
            }
        }
        return code;
    }

    /** Adds import to set imports set. */
    private String generateImport(Class<?> cls) {
        String name = cls.getName();
        int lastDotIndex = name.lastIndexOf('.');
        if (lastDotIndex == -1)
            return null;

        if (DESTINATION_PACKAGE.equals(name.substring(0, lastDotIndex)))
            return null;

        return "import " + DOLLAR_PATTERN.matcher(cls.getName()).replaceAll(".") + ';';
    }

    private static String getAccessorOrNull(Class<?> source, String methodName)
    {
        boolean isStatic = Arrays.stream(source.getMethods())
                                    .filter(m -> m.getName().equals(methodName))
                                    .anyMatch(m -> Modifier.isStatic(m.getModifiers()));

        return methodName == null ? "null" : (isStatic ? source.getSimpleName() : "source") + "::" + methodName;
    }

    private static String getType(Class<?> typeClazz)
    {
        if (typeClazz.isPrimitive())
            return ClassUtils.primitiveToWrapper(typeClazz).getSimpleName() + ".TYPE";
        else
        {
            String name = typeClazz.getName();
            int lastDotIndex = name.lastIndexOf('.');
            if (lastDotIndex == -1)
                return name;

            return DOLLAR_PATTERN.matcher(name.substring(lastDotIndex + 1)).replaceAll(".") + ".class";
        }
    }

    private static String convertToCamelCase(String name)
    {
        String[] parts = name.split("_");
        StringBuilder camelCaseString = new StringBuilder();
        for (String part : parts)
        {
            camelCaseString.append(part.substring(0, 1).toUpperCase());
            camelCaseString.append(part.substring(1).toLowerCase());
        }
        return camelCaseString.toString();
    }

    private static Field[] getConfigEditableFields()
    {
        return Arrays.stream(CONFIG_CLASS.getFields())
                     .filter(f -> !Modifier.isFinal(f.getModifiers()))
                     .filter(f -> !Modifier.isStatic(f.getModifiers()))
                     .filter(f -> !Modifier.isPrivate(f.getModifiers()))
                     .filter(f -> !f.getType().isArray() || f.getType().isEnum())
                     .toArray(Field[]::new);
    }
}
