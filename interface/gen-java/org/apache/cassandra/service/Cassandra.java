/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.cassandra.service;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import org.apache.log4j.Logger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class Cassandra {

  public interface Iface {

    public List<Column> get_slice_by_names(String table, String key, ColumnParent column_parent, List<byte[]> column_names) throws InvalidRequestException, NotFoundException, TException;

    public List<Column> get_slice(String table, String key, ColumnParent column_parent, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, NotFoundException, TException;

    public Column get_column(String table, String key, ColumnPath column_path) throws InvalidRequestException, NotFoundException, TException;

    public int get_column_count(String table, String key, ColumnParent column_parent) throws InvalidRequestException, TException;

    public void insert(String table, String key, ColumnPath column_path, byte[] value, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException;

    public void batch_insert(String table, BatchMutation batch_mutation, int block_for) throws InvalidRequestException, UnavailableException, TException;

    public void remove(String table, String key, ColumnPathOrParent column_path_or_parent, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException;

    public List<SuperColumn> get_slice_super(String table, String key, String column_family, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, TException;

    public List<SuperColumn> get_slice_super_by_names(String table, String key, String column_family, List<byte[]> super_column_names) throws InvalidRequestException, TException;

    public SuperColumn get_super_column(String table, String key, SuperColumnPath super_column_path) throws InvalidRequestException, NotFoundException, TException;

    public void batch_insert_super_column(String table, BatchMutationSuper batch_mutation_super, int block_for) throws InvalidRequestException, UnavailableException, TException;

    public List<String> get_key_range(String table, String column_family, String startWith, String stopAt, int maxResults) throws InvalidRequestException, TException;

    public String getStringProperty(String propertyName) throws TException;

    public List<String> getStringListProperty(String propertyName) throws TException;

    public Map<String,Map<String,String>> describeTable(String tableName) throws NotFoundException, TException;

    public CqlResult executeQuery(String query) throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public List<Column> get_slice_by_names(String table, String key, ColumnParent column_parent, List<byte[]> column_names) throws InvalidRequestException, NotFoundException, TException
    {
      send_get_slice_by_names(table, key, column_parent, column_names);
      return recv_get_slice_by_names();
    }

    public void send_get_slice_by_names(String table, String key, ColumnParent column_parent, List<byte[]> column_names) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.CALL, seqid_));
      get_slice_by_names_args args = new get_slice_by_names_args();
      args.table = table;
      args.key = key;
      args.column_parent = column_parent;
      args.column_names = column_names;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Column> recv_get_slice_by_names() throws InvalidRequestException, NotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_by_names_result result = new get_slice_by_names_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_by_names failed: unknown result");
    }

    public List<Column> get_slice(String table, String key, ColumnParent column_parent, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, NotFoundException, TException
    {
      send_get_slice(table, key, column_parent, start, finish, is_ascending, count);
      return recv_get_slice();
    }

    public void send_get_slice(String table, String key, ColumnParent column_parent, byte[] start, byte[] finish, boolean is_ascending, int count) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice", TMessageType.CALL, seqid_));
      get_slice_args args = new get_slice_args();
      args.table = table;
      args.key = key;
      args.column_parent = column_parent;
      args.start = start;
      args.finish = finish;
      args.is_ascending = is_ascending;
      args.count = count;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Column> recv_get_slice() throws InvalidRequestException, NotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_result result = new get_slice_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
    }

    public Column get_column(String table, String key, ColumnPath column_path) throws InvalidRequestException, NotFoundException, TException
    {
      send_get_column(table, key, column_path);
      return recv_get_column();
    }

    public void send_get_column(String table, String key, ColumnPath column_path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_column", TMessageType.CALL, seqid_));
      get_column_args args = new get_column_args();
      args.table = table;
      args.key = key;
      args.column_path = column_path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Column recv_get_column() throws InvalidRequestException, NotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_column_result result = new get_column_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_column failed: unknown result");
    }

    public int get_column_count(String table, String key, ColumnParent column_parent) throws InvalidRequestException, TException
    {
      send_get_column_count(table, key, column_parent);
      return recv_get_column_count();
    }

    public void send_get_column_count(String table, String key, ColumnParent column_parent) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_column_count", TMessageType.CALL, seqid_));
      get_column_count_args args = new get_column_count_args();
      args.table = table;
      args.key = key;
      args.column_parent = column_parent;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_get_column_count() throws InvalidRequestException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_column_count_result result = new get_column_count_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_column_count failed: unknown result");
    }

    public void insert(String table, String key, ColumnPath column_path, byte[] value, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException
    {
      send_insert(table, key, column_path, value, timestamp, block_for);
      recv_insert();
    }

    public void send_insert(String table, String key, ColumnPath column_path, byte[] value, long timestamp, int block_for) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("insert", TMessageType.CALL, seqid_));
      insert_args args = new insert_args();
      args.table = table;
      args.key = key;
      args.column_path = column_path;
      args.value = value;
      args.timestamp = timestamp;
      args.block_for = block_for;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_insert() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      insert_result result = new insert_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      return;
    }

    public void batch_insert(String table, BatchMutation batch_mutation, int block_for) throws InvalidRequestException, UnavailableException, TException
    {
      send_batch_insert(table, batch_mutation, block_for);
      recv_batch_insert();
    }

    public void send_batch_insert(String table, BatchMutation batch_mutation, int block_for) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("batch_insert", TMessageType.CALL, seqid_));
      batch_insert_args args = new batch_insert_args();
      args.table = table;
      args.batch_mutation = batch_mutation;
      args.block_for = block_for;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_batch_insert() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      batch_insert_result result = new batch_insert_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      return;
    }

    public void remove(String table, String key, ColumnPathOrParent column_path_or_parent, long timestamp, int block_for) throws InvalidRequestException, UnavailableException, TException
    {
      send_remove(table, key, column_path_or_parent, timestamp, block_for);
      recv_remove();
    }

    public void send_remove(String table, String key, ColumnPathOrParent column_path_or_parent, long timestamp, int block_for) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.table = table;
      args.key = key;
      args.column_path_or_parent = column_path_or_parent;
      args.timestamp = timestamp;
      args.block_for = block_for;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_remove() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      return;
    }

    public List<SuperColumn> get_slice_super(String table, String key, String column_family, byte[] start, byte[] finish, boolean is_ascending, int count) throws InvalidRequestException, TException
    {
      send_get_slice_super(table, key, column_family, start, finish, is_ascending, count);
      return recv_get_slice_super();
    }

    public void send_get_slice_super(String table, String key, String column_family, byte[] start, byte[] finish, boolean is_ascending, int count) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice_super", TMessageType.CALL, seqid_));
      get_slice_super_args args = new get_slice_super_args();
      args.table = table;
      args.key = key;
      args.column_family = column_family;
      args.start = start;
      args.finish = finish;
      args.is_ascending = is_ascending;
      args.count = count;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<SuperColumn> recv_get_slice_super() throws InvalidRequestException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_super_result result = new get_slice_super_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super failed: unknown result");
    }

    public List<SuperColumn> get_slice_super_by_names(String table, String key, String column_family, List<byte[]> super_column_names) throws InvalidRequestException, TException
    {
      send_get_slice_super_by_names(table, key, column_family, super_column_names);
      return recv_get_slice_super_by_names();
    }

    public void send_get_slice_super_by_names(String table, String key, String column_family, List<byte[]> super_column_names) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.CALL, seqid_));
      get_slice_super_by_names_args args = new get_slice_super_by_names_args();
      args.table = table;
      args.key = key;
      args.column_family = column_family;
      args.super_column_names = super_column_names;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<SuperColumn> recv_get_slice_super_by_names() throws InvalidRequestException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_super_by_names_result result = new get_slice_super_by_names_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super_by_names failed: unknown result");
    }

    public SuperColumn get_super_column(String table, String key, SuperColumnPath super_column_path) throws InvalidRequestException, NotFoundException, TException
    {
      send_get_super_column(table, key, super_column_path);
      return recv_get_super_column();
    }

    public void send_get_super_column(String table, String key, SuperColumnPath super_column_path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_super_column", TMessageType.CALL, seqid_));
      get_super_column_args args = new get_super_column_args();
      args.table = table;
      args.key = key;
      args.super_column_path = super_column_path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public SuperColumn recv_get_super_column() throws InvalidRequestException, NotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_super_column_result result = new get_super_column_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_super_column failed: unknown result");
    }

    public void batch_insert_super_column(String table, BatchMutationSuper batch_mutation_super, int block_for) throws InvalidRequestException, UnavailableException, TException
    {
      send_batch_insert_super_column(table, batch_mutation_super, block_for);
      recv_batch_insert_super_column();
    }

    public void send_batch_insert_super_column(String table, BatchMutationSuper batch_mutation_super, int block_for) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.CALL, seqid_));
      batch_insert_super_column_args args = new batch_insert_super_column_args();
      args.table = table;
      args.batch_mutation_super = batch_mutation_super;
      args.block_for = block_for;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_batch_insert_super_column() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      batch_insert_super_column_result result = new batch_insert_super_column_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      return;
    }

    public List<String> get_key_range(String table, String column_family, String startWith, String stopAt, int maxResults) throws InvalidRequestException, TException
    {
      send_get_key_range(table, column_family, startWith, stopAt, maxResults);
      return recv_get_key_range();
    }

    public void send_get_key_range(String table, String column_family, String startWith, String stopAt, int maxResults) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_key_range", TMessageType.CALL, seqid_));
      get_key_range_args args = new get_key_range_args();
      args.table = table;
      args.column_family = column_family;
      args.startWith = startWith;
      args.stopAt = stopAt;
      args.maxResults = maxResults;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_key_range() throws InvalidRequestException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_key_range_result result = new get_key_range_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_key_range failed: unknown result");
    }

    public String getStringProperty(String propertyName) throws TException
    {
      send_getStringProperty(propertyName);
      return recv_getStringProperty();
    }

    public void send_getStringProperty(String propertyName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getStringProperty", TMessageType.CALL, seqid_));
      getStringProperty_args args = new getStringProperty_args();
      args.propertyName = propertyName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getStringProperty() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getStringProperty_result result = new getStringProperty_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStringProperty failed: unknown result");
    }

    public List<String> getStringListProperty(String propertyName) throws TException
    {
      send_getStringListProperty(propertyName);
      return recv_getStringListProperty();
    }

    public void send_getStringListProperty(String propertyName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getStringListProperty", TMessageType.CALL, seqid_));
      getStringListProperty_args args = new getStringListProperty_args();
      args.propertyName = propertyName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getStringListProperty() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getStringListProperty_result result = new getStringListProperty_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStringListProperty failed: unknown result");
    }

    public Map<String,Map<String,String>> describeTable(String tableName) throws NotFoundException, TException
    {
      send_describeTable(tableName);
      return recv_describeTable();
    }

    public void send_describeTable(String tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("describeTable", TMessageType.CALL, seqid_));
      describeTable_args args = new describeTable_args();
      args.tableName = tableName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,Map<String,String>> recv_describeTable() throws NotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      describeTable_result result = new describeTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "describeTable failed: unknown result");
    }

    public CqlResult executeQuery(String query) throws TException
    {
      send_executeQuery(query);
      return recv_executeQuery();
    }

    public void send_executeQuery(String query) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("executeQuery", TMessageType.CALL, seqid_));
      executeQuery_args args = new executeQuery_args();
      args.query = query;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public CqlResult recv_executeQuery() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      executeQuery_result result = new executeQuery_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "executeQuery failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("get_slice_by_names", new get_slice_by_names());
      processMap_.put("get_slice", new get_slice());
      processMap_.put("get_column", new get_column());
      processMap_.put("get_column_count", new get_column_count());
      processMap_.put("insert", new insert());
      processMap_.put("batch_insert", new batch_insert());
      processMap_.put("remove", new remove());
      processMap_.put("get_slice_super", new get_slice_super());
      processMap_.put("get_slice_super_by_names", new get_slice_super_by_names());
      processMap_.put("get_super_column", new get_super_column());
      processMap_.put("batch_insert_super_column", new batch_insert_super_column());
      processMap_.put("get_key_range", new get_key_range());
      processMap_.put("getStringProperty", new getStringProperty());
      processMap_.put("getStringListProperty", new getStringListProperty());
      processMap_.put("describeTable", new describeTable());
      processMap_.put("executeQuery", new executeQuery());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class get_slice_by_names implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_by_names_args args = new get_slice_by_names_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_by_names_result result = new get_slice_by_names_result();
        try {
          result.success = iface_.get_slice_by_names(args.table, args.key, args.column_parent, args.column_names);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_slice_by_names", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice_by_names");
          oprot.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_slice implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_args args = new get_slice_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_result result = new get_slice_result();
        try {
          result.success = iface_.get_slice(args.table, args.key, args.column_parent, args.start, args.finish, args.is_ascending, args.count);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_slice", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice");
          oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_column implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_column_args args = new get_column_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_column_result result = new get_column_result();
        try {
          result.success = iface_.get_column(args.table, args.key, args.column_path);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_column", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_column");
          oprot.writeMessageBegin(new TMessage("get_column", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_column", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_column_count implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_column_count_args args = new get_column_count_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_column_count_result result = new get_column_count_result();
        try {
          result.success = iface_.get_column_count(args.table, args.key, args.column_parent);
          result.__isset.success = true;
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_column_count", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_column_count");
          oprot.writeMessageBegin(new TMessage("get_column_count", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_column_count", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class insert implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        insert_args args = new insert_args();
        args.read(iprot);
        iprot.readMessageEnd();
        insert_result result = new insert_result();
        try {
          iface_.insert(args.table, args.key, args.column_path, args.value, args.timestamp, args.block_for);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing insert", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing insert");
          oprot.writeMessageBegin(new TMessage("insert", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("insert", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class batch_insert implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        batch_insert_args args = new batch_insert_args();
        args.read(iprot);
        iprot.readMessageEnd();
        batch_insert_result result = new batch_insert_result();
        try {
          iface_.batch_insert(args.table, args.batch_mutation, args.block_for);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing batch_insert", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert");
          oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        remove_args args = new remove_args();
        args.read(iprot);
        iprot.readMessageEnd();
        remove_result result = new remove_result();
        try {
          iface_.remove(args.table, args.key, args.column_path_or_parent, args.timestamp, args.block_for);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing remove", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing remove");
          oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_slice_super implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_super_args args = new get_slice_super_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_super_result result = new get_slice_super_result();
        try {
          result.success = iface_.get_slice_super(args.table, args.key, args.column_family, args.start, args.finish, args.is_ascending, args.count);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_slice_super", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice_super");
          oprot.writeMessageBegin(new TMessage("get_slice_super", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_slice_super", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_slice_super_by_names implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_super_by_names_args args = new get_slice_super_by_names_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_super_by_names_result result = new get_slice_super_by_names_result();
        try {
          result.success = iface_.get_slice_super_by_names(args.table, args.key, args.column_family, args.super_column_names);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_slice_super_by_names", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice_super_by_names");
          oprot.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_super_column implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_super_column_args args = new get_super_column_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_super_column_result result = new get_super_column_result();
        try {
          result.success = iface_.get_super_column(args.table, args.key, args.super_column_path);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_super_column", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_super_column");
          oprot.writeMessageBegin(new TMessage("get_super_column", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_super_column", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class batch_insert_super_column implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        batch_insert_super_column_args args = new batch_insert_super_column_args();
        args.read(iprot);
        iprot.readMessageEnd();
        batch_insert_super_column_result result = new batch_insert_super_column_result();
        try {
          iface_.batch_insert_super_column(args.table, args.batch_mutation_super, args.block_for);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing batch_insert_super_column", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert_super_column");
          oprot.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("batch_insert_super_column", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_key_range implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_key_range_args args = new get_key_range_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_key_range_result result = new get_key_range_result();
        try {
          result.success = iface_.get_key_range(args.table, args.column_family, args.startWith, args.stopAt, args.maxResults);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_key_range", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_key_range");
          oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getStringProperty implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getStringProperty_args args = new getStringProperty_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getStringProperty_result result = new getStringProperty_result();
        result.success = iface_.getStringProperty(args.propertyName);
        oprot.writeMessageBegin(new TMessage("getStringProperty", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getStringListProperty implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getStringListProperty_args args = new getStringListProperty_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getStringListProperty_result result = new getStringListProperty_result();
        result.success = iface_.getStringListProperty(args.propertyName);
        oprot.writeMessageBegin(new TMessage("getStringListProperty", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class describeTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        describeTable_args args = new describeTable_args();
        args.read(iprot);
        iprot.readMessageEnd();
        describeTable_result result = new describeTable_result();
        try {
          result.success = iface_.describeTable(args.tableName);
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing describeTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing describeTable");
          oprot.writeMessageBegin(new TMessage("describeTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("describeTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class executeQuery implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        executeQuery_args args = new executeQuery_args();
        args.read(iprot);
        iprot.readMessageEnd();
        executeQuery_result result = new executeQuery_result();
        result.success = iface_.executeQuery(args.query);
        oprot.writeMessageBegin(new TMessage("executeQuery", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class get_slice_by_names_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_by_names_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
    private static final TField COLUMN_NAMES_FIELD_DESC = new TField("column_names", TType.LIST, (short)4);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public ColumnParent column_parent;
    public static final int COLUMN_PARENT = 3;
    public List<byte[]> column_names;
    public static final int COLUMN_NAMES = 4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ColumnParent.class)));
      put(COLUMN_NAMES, new FieldMetaData("column_names", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_by_names_args.class, metaDataMap);
    }

    public get_slice_by_names_args() {
    }

    public get_slice_by_names_args(
      String table,
      String key,
      ColumnParent column_parent,
      List<byte[]> column_names)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_parent = column_parent;
      this.column_names = column_names;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_by_names_args(get_slice_by_names_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_parent()) {
        this.column_parent = new ColumnParent(other.column_parent);
      }
      if (other.isSetColumn_names()) {
        List<byte[]> __this__column_names = new ArrayList<byte[]>();
        for (byte[] other_element : other.column_names) {
          byte[] temp_binary_element = new byte[other_element.length];
          System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
          __this__column_names.add(temp_binary_element);
        }
        this.column_names = __this__column_names;
      }
    }

    @Override
    public get_slice_by_names_args clone() {
      return new get_slice_by_names_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
    }

    public void setColumn_parent(ColumnParent column_parent) {
      this.column_parent = column_parent;
    }

    public void unsetColumn_parent() {
      this.column_parent = null;
    }

    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_parent() {
      return this.column_parent != null;
    }

    public void setColumn_parentIsSet(boolean value) {
      if (!value) {
        this.column_parent = null;
      }
    }

    public int getColumn_namesSize() {
      return (this.column_names == null) ? 0 : this.column_names.size();
    }

    public java.util.Iterator<byte[]> getColumn_namesIterator() {
      return (this.column_names == null) ? null : this.column_names.iterator();
    }

    public void addToColumn_names(byte[] elem) {
      if (this.column_names == null) {
        this.column_names = new ArrayList<byte[]>();
      }
      this.column_names.add(elem);
    }

    public List<byte[]> getColumn_names() {
      return this.column_names;
    }

    public void setColumn_names(List<byte[]> column_names) {
      this.column_names = column_names;
    }

    public void unsetColumn_names() {
      this.column_names = null;
    }

    // Returns true if field column_names is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_names() {
      return this.column_names != null;
    }

    public void setColumn_namesIsSet(boolean value) {
      if (!value) {
        this.column_names = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PARENT:
        if (value == null) {
          unsetColumn_parent();
        } else {
          setColumn_parent((ColumnParent)value);
        }
        break;

      case COLUMN_NAMES:
        if (value == null) {
          unsetColumn_names();
        } else {
          setColumn_names((List<byte[]>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_PARENT:
        return getColumn_parent();

      case COLUMN_NAMES:
        return getColumn_names();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_PARENT:
        return isSetColumn_parent();
      case COLUMN_NAMES:
        return isSetColumn_names();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_by_names_args)
        return this.equals((get_slice_by_names_args)that);
      return false;
    }

    public boolean equals(get_slice_by_names_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_parent = true && this.isSetColumn_parent();
      boolean that_present_column_parent = true && that.isSetColumn_parent();
      if (this_present_column_parent || that_present_column_parent) {
        if (!(this_present_column_parent && that_present_column_parent))
          return false;
        if (!this.column_parent.equals(that.column_parent))
          return false;
      }

      boolean this_present_column_names = true && this.isSetColumn_names();
      boolean that_present_column_names = true && that.isSetColumn_names();
      if (this_present_column_names || that_present_column_names) {
        if (!(this_present_column_names && that_present_column_names))
          return false;
        if (!this.column_names.equals(that.column_names))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PARENT:
            if (field.type == TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_NAMES:
            if (field.type == TType.LIST) {
              {
                TList _list31 = iprot.readListBegin();
                this.column_names = new ArrayList<byte[]>(_list31.size);
                for (int _i32 = 0; _i32 < _list31.size; ++_i32)
                {
                  byte[] _elem33;
                  _elem33 = iprot.readBinary();
                  this.column_names.add(_elem33);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_parent != null) {
        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
        this.column_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.column_names != null) {
        oprot.writeFieldBegin(COLUMN_NAMES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.column_names.size()));
          for (byte[] _iter34 : this.column_names)          {
            oprot.writeBinary(_iter34);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_by_names_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_parent:");
      if (this.column_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_parent);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_names:");
      if (this.column_names == null) {
        sb.append("null");
      } else {
        sb.append(this.column_names);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_by_names_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_by_names_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);

    public List<Column> success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;
    public NotFoundException nfe;
    public static final int NFE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Column.class))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_by_names_result.class, metaDataMap);
    }

    public get_slice_by_names_result() {
    }

    public get_slice_by_names_result(
      List<Column> success,
      InvalidRequestException ire,
      NotFoundException nfe)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.nfe = nfe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_by_names_result(get_slice_by_names_result other) {
      if (other.isSetSuccess()) {
        List<Column> __this__success = new ArrayList<Column>();
        for (Column other_element : other.success) {
          __this__success.add(new Column(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
    }

    @Override
    public get_slice_by_names_result clone() {
      return new get_slice_by_names_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Column> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Column elem) {
      if (this.success == null) {
        this.success = new ArrayList<Column>();
      }
      this.success.add(elem);
    }

    public List<Column> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Column> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public void setNfe(NotFoundException nfe) {
      this.nfe = nfe;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Column>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case NFE:
        return getNfe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case NFE:
        return isSetNfe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_by_names_result)
        return this.equals((get_slice_by_names_result)that);
      return false;
    }

    public boolean equals(get_slice_by_names_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list35 = iprot.readListBegin();
                this.success = new ArrayList<Column>(_list35.size);
                for (int _i36 = 0; _i36 < _list35.size; ++_i36)
                {
                  Column _elem37;
                  _elem37 = new Column();
                  _elem37.read(iprot);
                  this.success.add(_elem37);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Column _iter38 : this.success)          {
            _iter38.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_by_names_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
    private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short)4);
    private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short)5);
    private static final TField IS_ASCENDING_FIELD_DESC = new TField("is_ascending", TType.BOOL, (short)6);
    private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)7);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public ColumnParent column_parent;
    public static final int COLUMN_PARENT = 3;
    public byte[] start;
    public static final int START = 4;
    public byte[] finish;
    public static final int FINISH = 5;
    public boolean is_ascending;
    public static final int IS_ASCENDING = 6;
    public int count;
    public static final int COUNT = 7;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean is_ascending = false;
      public boolean count = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ColumnParent.class)));
      put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(FINISH, new FieldMetaData("finish", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(IS_ASCENDING, new FieldMetaData("is_ascending", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_args.class, metaDataMap);
    }

    public get_slice_args() {
      this.count = 100;

    }

    public get_slice_args(
      String table,
      String key,
      ColumnParent column_parent,
      byte[] start,
      byte[] finish,
      boolean is_ascending,
      int count)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_parent = column_parent;
      this.start = start;
      this.finish = finish;
      this.is_ascending = is_ascending;
      this.__isset.is_ascending = true;
      this.count = count;
      this.__isset.count = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_args(get_slice_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_parent()) {
        this.column_parent = new ColumnParent(other.column_parent);
      }
      if (other.isSetStart()) {
        this.start = new byte[other.start.length];
        System.arraycopy(other.start, 0, start, 0, other.start.length);
      }
      if (other.isSetFinish()) {
        this.finish = new byte[other.finish.length];
        System.arraycopy(other.finish, 0, finish, 0, other.finish.length);
      }
      __isset.is_ascending = other.__isset.is_ascending;
      this.is_ascending = other.is_ascending;
      __isset.count = other.__isset.count;
      this.count = other.count;
    }

    @Override
    public get_slice_args clone() {
      return new get_slice_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
    }

    public void setColumn_parent(ColumnParent column_parent) {
      this.column_parent = column_parent;
    }

    public void unsetColumn_parent() {
      this.column_parent = null;
    }

    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_parent() {
      return this.column_parent != null;
    }

    public void setColumn_parentIsSet(boolean value) {
      if (!value) {
        this.column_parent = null;
      }
    }

    public byte[] getStart() {
      return this.start;
    }

    public void setStart(byte[] start) {
      this.start = start;
    }

    public void unsetStart() {
      this.start = null;
    }

    // Returns true if field start is set (has been asigned a value) and false otherwise
    public boolean isSetStart() {
      return this.start != null;
    }

    public void setStartIsSet(boolean value) {
      if (!value) {
        this.start = null;
      }
    }

    public byte[] getFinish() {
      return this.finish;
    }

    public void setFinish(byte[] finish) {
      this.finish = finish;
    }

    public void unsetFinish() {
      this.finish = null;
    }

    // Returns true if field finish is set (has been asigned a value) and false otherwise
    public boolean isSetFinish() {
      return this.finish != null;
    }

    public void setFinishIsSet(boolean value) {
      if (!value) {
        this.finish = null;
      }
    }

    public boolean isIs_ascending() {
      return this.is_ascending;
    }

    public void setIs_ascending(boolean is_ascending) {
      this.is_ascending = is_ascending;
      this.__isset.is_ascending = true;
    }

    public void unsetIs_ascending() {
      this.__isset.is_ascending = false;
    }

    // Returns true if field is_ascending is set (has been asigned a value) and false otherwise
    public boolean isSetIs_ascending() {
      return this.__isset.is_ascending;
    }

    public void setIs_ascendingIsSet(boolean value) {
      this.__isset.is_ascending = value;
    }

    public int getCount() {
      return this.count;
    }

    public void setCount(int count) {
      this.count = count;
      this.__isset.count = true;
    }

    public void unsetCount() {
      this.__isset.count = false;
    }

    // Returns true if field count is set (has been asigned a value) and false otherwise
    public boolean isSetCount() {
      return this.__isset.count;
    }

    public void setCountIsSet(boolean value) {
      this.__isset.count = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PARENT:
        if (value == null) {
          unsetColumn_parent();
        } else {
          setColumn_parent((ColumnParent)value);
        }
        break;

      case START:
        if (value == null) {
          unsetStart();
        } else {
          setStart((byte[])value);
        }
        break;

      case FINISH:
        if (value == null) {
          unsetFinish();
        } else {
          setFinish((byte[])value);
        }
        break;

      case IS_ASCENDING:
        if (value == null) {
          unsetIs_ascending();
        } else {
          setIs_ascending((Boolean)value);
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          setCount((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_PARENT:
        return getColumn_parent();

      case START:
        return getStart();

      case FINISH:
        return getFinish();

      case IS_ASCENDING:
        return new Boolean(isIs_ascending());

      case COUNT:
        return new Integer(getCount());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_PARENT:
        return isSetColumn_parent();
      case START:
        return isSetStart();
      case FINISH:
        return isSetFinish();
      case IS_ASCENDING:
        return isSetIs_ascending();
      case COUNT:
        return isSetCount();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_args)
        return this.equals((get_slice_args)that);
      return false;
    }

    public boolean equals(get_slice_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_parent = true && this.isSetColumn_parent();
      boolean that_present_column_parent = true && that.isSetColumn_parent();
      if (this_present_column_parent || that_present_column_parent) {
        if (!(this_present_column_parent && that_present_column_parent))
          return false;
        if (!this.column_parent.equals(that.column_parent))
          return false;
      }

      boolean this_present_start = true && this.isSetStart();
      boolean that_present_start = true && that.isSetStart();
      if (this_present_start || that_present_start) {
        if (!(this_present_start && that_present_start))
          return false;
        if (!java.util.Arrays.equals(this.start, that.start))
          return false;
      }

      boolean this_present_finish = true && this.isSetFinish();
      boolean that_present_finish = true && that.isSetFinish();
      if (this_present_finish || that_present_finish) {
        if (!(this_present_finish && that_present_finish))
          return false;
        if (!java.util.Arrays.equals(this.finish, that.finish))
          return false;
      }

      boolean this_present_is_ascending = true;
      boolean that_present_is_ascending = true;
      if (this_present_is_ascending || that_present_is_ascending) {
        if (!(this_present_is_ascending && that_present_is_ascending))
          return false;
        if (this.is_ascending != that.is_ascending)
          return false;
      }

      boolean this_present_count = true;
      boolean that_present_count = true;
      if (this_present_count || that_present_count) {
        if (!(this_present_count && that_present_count))
          return false;
        if (this.count != that.count)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PARENT:
            if (field.type == TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START:
            if (field.type == TType.STRING) {
              this.start = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case FINISH:
            if (field.type == TType.STRING) {
              this.finish = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IS_ASCENDING:
            if (field.type == TType.BOOL) {
              this.is_ascending = iprot.readBool();
              this.__isset.is_ascending = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COUNT:
            if (field.type == TType.I32) {
              this.count = iprot.readI32();
              this.__isset.count = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_parent != null) {
        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
        this.column_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.start != null) {
        oprot.writeFieldBegin(START_FIELD_DESC);
        oprot.writeBinary(this.start);
        oprot.writeFieldEnd();
      }
      if (this.finish != null) {
        oprot.writeFieldBegin(FINISH_FIELD_DESC);
        oprot.writeBinary(this.finish);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(IS_ASCENDING_FIELD_DESC);
      oprot.writeBool(this.is_ascending);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(COUNT_FIELD_DESC);
      oprot.writeI32(this.count);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_parent:");
      if (this.column_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_parent);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("start:");
      if (this.start == null) {
        sb.append("null");
      } else {
          int __start_size = Math.min(this.start.length, 128);
          for (int i = 0; i < __start_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.start[i]).length() > 1 ? Integer.toHexString(this.start[i]).substring(Integer.toHexString(this.start[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.start[i]).toUpperCase());
          }
          if (this.start.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("finish:");
      if (this.finish == null) {
        sb.append("null");
      } else {
          int __finish_size = Math.min(this.finish.length, 128);
          for (int i = 0; i < __finish_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.finish[i]).length() > 1 ? Integer.toHexString(this.finish[i]).substring(Integer.toHexString(this.finish[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.finish[i]).toUpperCase());
          }
          if (this.finish.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("is_ascending:");
      sb.append(this.is_ascending);
      first = false;
      if (!first) sb.append(", ");
      sb.append("count:");
      sb.append(this.count);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);

    public List<Column> success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;
    public NotFoundException nfe;
    public static final int NFE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Column.class))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_result.class, metaDataMap);
    }

    public get_slice_result() {
    }

    public get_slice_result(
      List<Column> success,
      InvalidRequestException ire,
      NotFoundException nfe)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.nfe = nfe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_result(get_slice_result other) {
      if (other.isSetSuccess()) {
        List<Column> __this__success = new ArrayList<Column>();
        for (Column other_element : other.success) {
          __this__success.add(new Column(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
    }

    @Override
    public get_slice_result clone() {
      return new get_slice_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Column> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Column elem) {
      if (this.success == null) {
        this.success = new ArrayList<Column>();
      }
      this.success.add(elem);
    }

    public List<Column> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Column> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public void setNfe(NotFoundException nfe) {
      this.nfe = nfe;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Column>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case NFE:
        return getNfe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case NFE:
        return isSetNfe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_result)
        return this.equals((get_slice_result)that);
      return false;
    }

    public boolean equals(get_slice_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list39 = iprot.readListBegin();
                this.success = new ArrayList<Column>(_list39.size);
                for (int _i40 = 0; _i40 < _list39.size; ++_i40)
                {
                  Column _elem41;
                  _elem41 = new Column();
                  _elem41.read(iprot);
                  this.success.add(_elem41);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Column _iter42 : this.success)          {
            _iter42.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public ColumnPath column_path;
    public static final int COLUMN_PATH = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ColumnPath.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_args.class, metaDataMap);
    }

    public get_column_args() {
    }

    public get_column_args(
      String table,
      String key,
      ColumnPath column_path)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_path = column_path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_args(get_column_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_path()) {
        this.column_path = new ColumnPath(other.column_path);
      }
    }

    @Override
    public get_column_args clone() {
      return new get_column_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnPath getColumn_path() {
      return this.column_path;
    }

    public void setColumn_path(ColumnPath column_path) {
      this.column_path = column_path;
    }

    public void unsetColumn_path() {
      this.column_path = null;
    }

    // Returns true if field column_path is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path() {
      return this.column_path != null;
    }

    public void setColumn_pathIsSet(boolean value) {
      if (!value) {
        this.column_path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PATH:
        if (value == null) {
          unsetColumn_path();
        } else {
          setColumn_path((ColumnPath)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_PATH:
        return getColumn_path();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_PATH:
        return isSetColumn_path();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_args)
        return this.equals((get_column_args)that);
      return false;
    }

    public boolean equals(get_column_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_path = true && this.isSetColumn_path();
      boolean that_present_column_path = true && that.isSetColumn_path();
      if (this_present_column_path || that_present_column_path) {
        if (!(this_present_column_path && that_present_column_path))
          return false;
        if (!this.column_path.equals(that.column_path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PATH:
            if (field.type == TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_path != null) {
        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
        this.column_path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_path:");
      if (this.column_path == null) {
        sb.append("null");
      } else {
        sb.append(this.column_path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);

    public Column success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;
    public NotFoundException nfe;
    public static final int NFE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Column.class)));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_result.class, metaDataMap);
    }

    public get_column_result() {
    }

    public get_column_result(
      Column success,
      InvalidRequestException ire,
      NotFoundException nfe)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.nfe = nfe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_result(get_column_result other) {
      if (other.isSetSuccess()) {
        this.success = new Column(other.success);
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
    }

    @Override
    public get_column_result clone() {
      return new get_column_result(this);
    }

    public Column getSuccess() {
      return this.success;
    }

    public void setSuccess(Column success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public void setNfe(NotFoundException nfe) {
      this.nfe = nfe;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Column)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case NFE:
        return getNfe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case NFE:
        return isSetNfe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_result)
        return this.equals((get_column_result)that);
      return false;
    }

    public boolean equals(get_column_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new Column();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_count_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_count_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public ColumnParent column_parent;
    public static final int COLUMN_PARENT = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ColumnParent.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_count_args.class, metaDataMap);
    }

    public get_column_count_args() {
    }

    public get_column_count_args(
      String table,
      String key,
      ColumnParent column_parent)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_parent = column_parent;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_count_args(get_column_count_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_parent()) {
        this.column_parent = new ColumnParent(other.column_parent);
      }
    }

    @Override
    public get_column_count_args clone() {
      return new get_column_count_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
    }

    public void setColumn_parent(ColumnParent column_parent) {
      this.column_parent = column_parent;
    }

    public void unsetColumn_parent() {
      this.column_parent = null;
    }

    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_parent() {
      return this.column_parent != null;
    }

    public void setColumn_parentIsSet(boolean value) {
      if (!value) {
        this.column_parent = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PARENT:
        if (value == null) {
          unsetColumn_parent();
        } else {
          setColumn_parent((ColumnParent)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_PARENT:
        return getColumn_parent();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_PARENT:
        return isSetColumn_parent();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_count_args)
        return this.equals((get_column_count_args)that);
      return false;
    }

    public boolean equals(get_column_count_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_parent = true && this.isSetColumn_parent();
      boolean that_present_column_parent = true && that.isSetColumn_parent();
      if (this_present_column_parent || that_present_column_parent) {
        if (!(this_present_column_parent && that_present_column_parent))
          return false;
        if (!this.column_parent.equals(that.column_parent))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PARENT:
            if (field.type == TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_parent != null) {
        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
        this.column_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_count_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_parent:");
      if (this.column_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_parent);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_count_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_count_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);

    public int success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_count_result.class, metaDataMap);
    }

    public get_column_count_result() {
    }

    public get_column_count_result(
      int success,
      InvalidRequestException ire)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ire = ire;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_count_result(get_column_count_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
    }

    @Override
    public get_column_count_result clone() {
      return new get_column_count_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public void setSuccess(int success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Integer(getSuccess());

      case IRE:
        return getIre();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_count_result)
        return this.equals((get_column_count_result)that);
      return false;
    }

    public boolean equals(get_column_count_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_count_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class insert_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("insert_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)4);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)5);
    private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)6);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public ColumnPath column_path;
    public static final int COLUMN_PATH = 3;
    public byte[] value;
    public static final int VALUE = 4;
    public long timestamp;
    public static final int TIMESTAMP = 5;
    public int block_for;
    public static final int BLOCK_FOR = 6;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean timestamp = false;
      public boolean block_for = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ColumnPath.class)));
      put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(insert_args.class, metaDataMap);
    }

    public insert_args() {
      this.block_for = 0;

    }

    public insert_args(
      String table,
      String key,
      ColumnPath column_path,
      byte[] value,
      long timestamp,
      int block_for)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_path = column_path;
      this.value = value;
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public insert_args(insert_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_path()) {
        this.column_path = new ColumnPath(other.column_path);
      }
      if (other.isSetValue()) {
        this.value = new byte[other.value.length];
        System.arraycopy(other.value, 0, value, 0, other.value.length);
      }
      __isset.timestamp = other.__isset.timestamp;
      this.timestamp = other.timestamp;
      __isset.block_for = other.__isset.block_for;
      this.block_for = other.block_for;
    }

    @Override
    public insert_args clone() {
      return new insert_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnPath getColumn_path() {
      return this.column_path;
    }

    public void setColumn_path(ColumnPath column_path) {
      this.column_path = column_path;
    }

    public void unsetColumn_path() {
      this.column_path = null;
    }

    // Returns true if field column_path is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path() {
      return this.column_path != null;
    }

    public void setColumn_pathIsSet(boolean value) {
      if (!value) {
        this.column_path = null;
      }
    }

    public byte[] getValue() {
      return this.value;
    }

    public void setValue(byte[] value) {
      this.value = value;
    }

    public void unsetValue() {
      this.value = null;
    }

    // Returns true if field value is set (has been asigned a value) and false otherwise
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public void setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
    }

    public void unsetTimestamp() {
      this.__isset.timestamp = false;
    }

    // Returns true if field timestamp is set (has been asigned a value) and false otherwise
    public boolean isSetTimestamp() {
      return this.__isset.timestamp;
    }

    public void setTimestampIsSet(boolean value) {
      this.__isset.timestamp = value;
    }

    public int getBlock_for() {
      return this.block_for;
    }

    public void setBlock_for(int block_for) {
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    public void unsetBlock_for() {
      this.__isset.block_for = false;
    }

    // Returns true if field block_for is set (has been asigned a value) and false otherwise
    public boolean isSetBlock_for() {
      return this.__isset.block_for;
    }

    public void setBlock_forIsSet(boolean value) {
      this.__isset.block_for = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PATH:
        if (value == null) {
          unsetColumn_path();
        } else {
          setColumn_path((ColumnPath)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((byte[])value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      case BLOCK_FOR:
        if (value == null) {
          unsetBlock_for();
        } else {
          setBlock_for((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_PATH:
        return getColumn_path();

      case VALUE:
        return getValue();

      case TIMESTAMP:
        return new Long(getTimestamp());

      case BLOCK_FOR:
        return new Integer(getBlock_for());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_PATH:
        return isSetColumn_path();
      case VALUE:
        return isSetValue();
      case TIMESTAMP:
        return isSetTimestamp();
      case BLOCK_FOR:
        return isSetBlock_for();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof insert_args)
        return this.equals((insert_args)that);
      return false;
    }

    public boolean equals(insert_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_path = true && this.isSetColumn_path();
      boolean that_present_column_path = true && that.isSetColumn_path();
      if (this_present_column_path || that_present_column_path) {
        if (!(this_present_column_path && that_present_column_path))
          return false;
        if (!this.column_path.equals(that.column_path))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!java.util.Arrays.equals(this.value, that.value))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      boolean this_present_block_for = true;
      boolean that_present_block_for = true;
      if (this_present_block_for || that_present_block_for) {
        if (!(this_present_block_for && that_present_block_for))
          return false;
        if (this.block_for != that.block_for)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PATH:
            if (field.type == TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case VALUE:
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMESTAMP:
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              this.__isset.timestamp = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BLOCK_FOR:
            if (field.type == TType.I32) {
              this.block_for = iprot.readI32();
              this.__isset.block_for = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_path != null) {
        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
        this.column_path.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
      oprot.writeI32(this.block_for);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("insert_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_path:");
      if (this.column_path == null) {
        sb.append("null");
      } else {
        sb.append(this.column_path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
          int __value_size = Math.min(this.value.length, 128);
          for (int i = 0; i < __value_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
          }
          if (this.value.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      if (!first) sb.append(", ");
      sb.append("block_for:");
      sb.append(this.block_for);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class insert_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("insert_result");
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public InvalidRequestException ire;
    public static final int IRE = 1;
    public UnavailableException ue;
    public static final int UE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(insert_result.class, metaDataMap);
    }

    public insert_result() {
    }

    public insert_result(
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public insert_result(insert_result other) {
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    @Override
    public insert_result clone() {
      return new insert_result(this);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public void setUe(UnavailableException ue) {
      this.ue = ue;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof insert_result)
        return this.equals((insert_result)that);
      return false;
    }

    public boolean equals(insert_result that) {
      if (that == null)
        return false;

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("insert_result(");
      boolean first = true;

      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField BATCH_MUTATION_FIELD_DESC = new TField("batch_mutation", TType.STRUCT, (short)2);
    private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)3);

    public String table;
    public static final int TABLE = 1;
    public BatchMutation batch_mutation;
    public static final int BATCH_MUTATION = 2;
    public int block_for;
    public static final int BLOCK_FOR = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean block_for = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(BATCH_MUTATION, new FieldMetaData("batch_mutation", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BatchMutation.class)));
      put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_args.class, metaDataMap);
    }

    public batch_insert_args() {
      this.block_for = 0;

    }

    public batch_insert_args(
      String table,
      BatchMutation batch_mutation,
      int block_for)
    {
      this();
      this.table = table;
      this.batch_mutation = batch_mutation;
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_args(batch_insert_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetBatch_mutation()) {
        this.batch_mutation = new BatchMutation(other.batch_mutation);
      }
      __isset.block_for = other.__isset.block_for;
      this.block_for = other.block_for;
    }

    @Override
    public batch_insert_args clone() {
      return new batch_insert_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public BatchMutation getBatch_mutation() {
      return this.batch_mutation;
    }

    public void setBatch_mutation(BatchMutation batch_mutation) {
      this.batch_mutation = batch_mutation;
    }

    public void unsetBatch_mutation() {
      this.batch_mutation = null;
    }

    // Returns true if field batch_mutation is set (has been asigned a value) and false otherwise
    public boolean isSetBatch_mutation() {
      return this.batch_mutation != null;
    }

    public void setBatch_mutationIsSet(boolean value) {
      if (!value) {
        this.batch_mutation = null;
      }
    }

    public int getBlock_for() {
      return this.block_for;
    }

    public void setBlock_for(int block_for) {
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    public void unsetBlock_for() {
      this.__isset.block_for = false;
    }

    // Returns true if field block_for is set (has been asigned a value) and false otherwise
    public boolean isSetBlock_for() {
      return this.__isset.block_for;
    }

    public void setBlock_forIsSet(boolean value) {
      this.__isset.block_for = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case BATCH_MUTATION:
        if (value == null) {
          unsetBatch_mutation();
        } else {
          setBatch_mutation((BatchMutation)value);
        }
        break;

      case BLOCK_FOR:
        if (value == null) {
          unsetBlock_for();
        } else {
          setBlock_for((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case BATCH_MUTATION:
        return getBatch_mutation();

      case BLOCK_FOR:
        return new Integer(getBlock_for());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case BATCH_MUTATION:
        return isSetBatch_mutation();
      case BLOCK_FOR:
        return isSetBlock_for();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_args)
        return this.equals((batch_insert_args)that);
      return false;
    }

    public boolean equals(batch_insert_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_batch_mutation = true && this.isSetBatch_mutation();
      boolean that_present_batch_mutation = true && that.isSetBatch_mutation();
      if (this_present_batch_mutation || that_present_batch_mutation) {
        if (!(this_present_batch_mutation && that_present_batch_mutation))
          return false;
        if (!this.batch_mutation.equals(that.batch_mutation))
          return false;
      }

      boolean this_present_block_for = true;
      boolean that_present_block_for = true;
      if (this_present_block_for || that_present_block_for) {
        if (!(this_present_block_for && that_present_block_for))
          return false;
        if (this.block_for != that.block_for)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BATCH_MUTATION:
            if (field.type == TType.STRUCT) {
              this.batch_mutation = new BatchMutation();
              this.batch_mutation.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BLOCK_FOR:
            if (field.type == TType.I32) {
              this.block_for = iprot.readI32();
              this.__isset.block_for = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.batch_mutation != null) {
        oprot.writeFieldBegin(BATCH_MUTATION_FIELD_DESC);
        this.batch_mutation.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
      oprot.writeI32(this.block_for);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("batch_mutation:");
      if (this.batch_mutation == null) {
        sb.append("null");
      } else {
        sb.append(this.batch_mutation);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("block_for:");
      sb.append(this.block_for);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_result");
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public InvalidRequestException ire;
    public static final int IRE = 1;
    public UnavailableException ue;
    public static final int UE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_result.class, metaDataMap);
    }

    public batch_insert_result() {
    }

    public batch_insert_result(
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_result(batch_insert_result other) {
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    @Override
    public batch_insert_result clone() {
      return new batch_insert_result(this);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public void setUe(UnavailableException ue) {
      this.ue = ue;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_result)
        return this.equals((batch_insert_result)that);
      return false;
    }

    public boolean equals(batch_insert_result that) {
      if (that == null)
        return false;

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_result(");
      boolean first = true;

      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PATH_OR_PARENT_FIELD_DESC = new TField("column_path_or_parent", TType.STRUCT, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);
    private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)5);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public ColumnPathOrParent column_path_or_parent;
    public static final int COLUMN_PATH_OR_PARENT = 3;
    public long timestamp;
    public static final int TIMESTAMP = 4;
    public int block_for;
    public static final int BLOCK_FOR = 5;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean timestamp = false;
      public boolean block_for = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PATH_OR_PARENT, new FieldMetaData("column_path_or_parent", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ColumnPathOrParent.class)));
      put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
      this.block_for = 0;

    }

    public remove_args(
      String table,
      String key,
      ColumnPathOrParent column_path_or_parent,
      long timestamp,
      int block_for)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_path_or_parent = column_path_or_parent;
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_path_or_parent()) {
        this.column_path_or_parent = new ColumnPathOrParent(other.column_path_or_parent);
      }
      __isset.timestamp = other.__isset.timestamp;
      this.timestamp = other.timestamp;
      __isset.block_for = other.__isset.block_for;
      this.block_for = other.block_for;
    }

    @Override
    public remove_args clone() {
      return new remove_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnPathOrParent getColumn_path_or_parent() {
      return this.column_path_or_parent;
    }

    public void setColumn_path_or_parent(ColumnPathOrParent column_path_or_parent) {
      this.column_path_or_parent = column_path_or_parent;
    }

    public void unsetColumn_path_or_parent() {
      this.column_path_or_parent = null;
    }

    // Returns true if field column_path_or_parent is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path_or_parent() {
      return this.column_path_or_parent != null;
    }

    public void setColumn_path_or_parentIsSet(boolean value) {
      if (!value) {
        this.column_path_or_parent = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public void setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
    }

    public void unsetTimestamp() {
      this.__isset.timestamp = false;
    }

    // Returns true if field timestamp is set (has been asigned a value) and false otherwise
    public boolean isSetTimestamp() {
      return this.__isset.timestamp;
    }

    public void setTimestampIsSet(boolean value) {
      this.__isset.timestamp = value;
    }

    public int getBlock_for() {
      return this.block_for;
    }

    public void setBlock_for(int block_for) {
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    public void unsetBlock_for() {
      this.__isset.block_for = false;
    }

    // Returns true if field block_for is set (has been asigned a value) and false otherwise
    public boolean isSetBlock_for() {
      return this.__isset.block_for;
    }

    public void setBlock_forIsSet(boolean value) {
      this.__isset.block_for = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PATH_OR_PARENT:
        if (value == null) {
          unsetColumn_path_or_parent();
        } else {
          setColumn_path_or_parent((ColumnPathOrParent)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      case BLOCK_FOR:
        if (value == null) {
          unsetBlock_for();
        } else {
          setBlock_for((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_PATH_OR_PARENT:
        return getColumn_path_or_parent();

      case TIMESTAMP:
        return new Long(getTimestamp());

      case BLOCK_FOR:
        return new Integer(getBlock_for());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_PATH_OR_PARENT:
        return isSetColumn_path_or_parent();
      case TIMESTAMP:
        return isSetTimestamp();
      case BLOCK_FOR:
        return isSetBlock_for();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_path_or_parent = true && this.isSetColumn_path_or_parent();
      boolean that_present_column_path_or_parent = true && that.isSetColumn_path_or_parent();
      if (this_present_column_path_or_parent || that_present_column_path_or_parent) {
        if (!(this_present_column_path_or_parent && that_present_column_path_or_parent))
          return false;
        if (!this.column_path_or_parent.equals(that.column_path_or_parent))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      boolean this_present_block_for = true;
      boolean that_present_block_for = true;
      if (this_present_block_for || that_present_block_for) {
        if (!(this_present_block_for && that_present_block_for))
          return false;
        if (this.block_for != that.block_for)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PATH_OR_PARENT:
            if (field.type == TType.STRUCT) {
              this.column_path_or_parent = new ColumnPathOrParent();
              this.column_path_or_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMESTAMP:
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              this.__isset.timestamp = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BLOCK_FOR:
            if (field.type == TType.I32) {
              this.block_for = iprot.readI32();
              this.__isset.block_for = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_path_or_parent != null) {
        oprot.writeFieldBegin(COLUMN_PATH_OR_PARENT_FIELD_DESC);
        this.column_path_or_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
      oprot.writeI32(this.block_for);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_path_or_parent:");
      if (this.column_path_or_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_path_or_parent);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      if (!first) sb.append(", ");
      sb.append("block_for:");
      sb.append(this.block_for);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public InvalidRequestException ire;
    public static final int IRE = 1;
    public UnavailableException ue;
    public static final int UE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    @Override
    public remove_result clone() {
      return new remove_result(this);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public void setUe(UnavailableException ue) {
      this.ue = ue;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_result(");
      boolean first = true;

      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)3);
    private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short)4);
    private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short)5);
    private static final TField IS_ASCENDING_FIELD_DESC = new TField("is_ascending", TType.BOOL, (short)6);
    private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)7);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public String column_family;
    public static final int COLUMN_FAMILY = 3;
    public byte[] start;
    public static final int START = 4;
    public byte[] finish;
    public static final int FINISH = 5;
    public boolean is_ascending;
    public static final int IS_ASCENDING = 6;
    public int count;
    public static final int COUNT = 7;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean is_ascending = false;
      public boolean count = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(FINISH, new FieldMetaData("finish", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(IS_ASCENDING, new FieldMetaData("is_ascending", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_args.class, metaDataMap);
    }

    public get_slice_super_args() {
      this.count = 100;

    }

    public get_slice_super_args(
      String table,
      String key,
      String column_family,
      byte[] start,
      byte[] finish,
      boolean is_ascending,
      int count)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_family = column_family;
      this.start = start;
      this.finish = finish;
      this.is_ascending = is_ascending;
      this.__isset.is_ascending = true;
      this.count = count;
      this.__isset.count = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_args(get_slice_super_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_family()) {
        this.column_family = other.column_family;
      }
      if (other.isSetStart()) {
        this.start = new byte[other.start.length];
        System.arraycopy(other.start, 0, start, 0, other.start.length);
      }
      if (other.isSetFinish()) {
        this.finish = new byte[other.finish.length];
        System.arraycopy(other.finish, 0, finish, 0, other.finish.length);
      }
      __isset.is_ascending = other.__isset.is_ascending;
      this.is_ascending = other.is_ascending;
      __isset.count = other.__isset.count;
      this.count = other.count;
    }

    @Override
    public get_slice_super_args clone() {
      return new get_slice_super_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getColumn_family() {
      return this.column_family;
    }

    public void setColumn_family(String column_family) {
      this.column_family = column_family;
    }

    public void unsetColumn_family() {
      this.column_family = null;
    }

    // Returns true if field column_family is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_family() {
      return this.column_family != null;
    }

    public void setColumn_familyIsSet(boolean value) {
      if (!value) {
        this.column_family = null;
      }
    }

    public byte[] getStart() {
      return this.start;
    }

    public void setStart(byte[] start) {
      this.start = start;
    }

    public void unsetStart() {
      this.start = null;
    }

    // Returns true if field start is set (has been asigned a value) and false otherwise
    public boolean isSetStart() {
      return this.start != null;
    }

    public void setStartIsSet(boolean value) {
      if (!value) {
        this.start = null;
      }
    }

    public byte[] getFinish() {
      return this.finish;
    }

    public void setFinish(byte[] finish) {
      this.finish = finish;
    }

    public void unsetFinish() {
      this.finish = null;
    }

    // Returns true if field finish is set (has been asigned a value) and false otherwise
    public boolean isSetFinish() {
      return this.finish != null;
    }

    public void setFinishIsSet(boolean value) {
      if (!value) {
        this.finish = null;
      }
    }

    public boolean isIs_ascending() {
      return this.is_ascending;
    }

    public void setIs_ascending(boolean is_ascending) {
      this.is_ascending = is_ascending;
      this.__isset.is_ascending = true;
    }

    public void unsetIs_ascending() {
      this.__isset.is_ascending = false;
    }

    // Returns true if field is_ascending is set (has been asigned a value) and false otherwise
    public boolean isSetIs_ascending() {
      return this.__isset.is_ascending;
    }

    public void setIs_ascendingIsSet(boolean value) {
      this.__isset.is_ascending = value;
    }

    public int getCount() {
      return this.count;
    }

    public void setCount(int count) {
      this.count = count;
      this.__isset.count = true;
    }

    public void unsetCount() {
      this.__isset.count = false;
    }

    // Returns true if field count is set (has been asigned a value) and false otherwise
    public boolean isSetCount() {
      return this.__isset.count;
    }

    public void setCountIsSet(boolean value) {
      this.__isset.count = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_FAMILY:
        if (value == null) {
          unsetColumn_family();
        } else {
          setColumn_family((String)value);
        }
        break;

      case START:
        if (value == null) {
          unsetStart();
        } else {
          setStart((byte[])value);
        }
        break;

      case FINISH:
        if (value == null) {
          unsetFinish();
        } else {
          setFinish((byte[])value);
        }
        break;

      case IS_ASCENDING:
        if (value == null) {
          unsetIs_ascending();
        } else {
          setIs_ascending((Boolean)value);
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          setCount((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_FAMILY:
        return getColumn_family();

      case START:
        return getStart();

      case FINISH:
        return getFinish();

      case IS_ASCENDING:
        return new Boolean(isIs_ascending());

      case COUNT:
        return new Integer(getCount());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_FAMILY:
        return isSetColumn_family();
      case START:
        return isSetStart();
      case FINISH:
        return isSetFinish();
      case IS_ASCENDING:
        return isSetIs_ascending();
      case COUNT:
        return isSetCount();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_args)
        return this.equals((get_slice_super_args)that);
      return false;
    }

    public boolean equals(get_slice_super_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_family = true && this.isSetColumn_family();
      boolean that_present_column_family = true && that.isSetColumn_family();
      if (this_present_column_family || that_present_column_family) {
        if (!(this_present_column_family && that_present_column_family))
          return false;
        if (!this.column_family.equals(that.column_family))
          return false;
      }

      boolean this_present_start = true && this.isSetStart();
      boolean that_present_start = true && that.isSetStart();
      if (this_present_start || that_present_start) {
        if (!(this_present_start && that_present_start))
          return false;
        if (!java.util.Arrays.equals(this.start, that.start))
          return false;
      }

      boolean this_present_finish = true && this.isSetFinish();
      boolean that_present_finish = true && that.isSetFinish();
      if (this_present_finish || that_present_finish) {
        if (!(this_present_finish && that_present_finish))
          return false;
        if (!java.util.Arrays.equals(this.finish, that.finish))
          return false;
      }

      boolean this_present_is_ascending = true;
      boolean that_present_is_ascending = true;
      if (this_present_is_ascending || that_present_is_ascending) {
        if (!(this_present_is_ascending && that_present_is_ascending))
          return false;
        if (this.is_ascending != that.is_ascending)
          return false;
      }

      boolean this_present_count = true;
      boolean that_present_count = true;
      if (this_present_count || that_present_count) {
        if (!(this_present_count && that_present_count))
          return false;
        if (this.count != that.count)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_FAMILY:
            if (field.type == TType.STRING) {
              this.column_family = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START:
            if (field.type == TType.STRING) {
              this.start = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case FINISH:
            if (field.type == TType.STRING) {
              this.finish = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IS_ASCENDING:
            if (field.type == TType.BOOL) {
              this.is_ascending = iprot.readBool();
              this.__isset.is_ascending = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COUNT:
            if (field.type == TType.I32) {
              this.count = iprot.readI32();
              this.__isset.count = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_family != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
        oprot.writeString(this.column_family);
        oprot.writeFieldEnd();
      }
      if (this.start != null) {
        oprot.writeFieldBegin(START_FIELD_DESC);
        oprot.writeBinary(this.start);
        oprot.writeFieldEnd();
      }
      if (this.finish != null) {
        oprot.writeFieldBegin(FINISH_FIELD_DESC);
        oprot.writeBinary(this.finish);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(IS_ASCENDING_FIELD_DESC);
      oprot.writeBool(this.is_ascending);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(COUNT_FIELD_DESC);
      oprot.writeI32(this.count);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_family:");
      if (this.column_family == null) {
        sb.append("null");
      } else {
        sb.append(this.column_family);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("start:");
      if (this.start == null) {
        sb.append("null");
      } else {
          int __start_size = Math.min(this.start.length, 128);
          for (int i = 0; i < __start_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.start[i]).length() > 1 ? Integer.toHexString(this.start[i]).substring(Integer.toHexString(this.start[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.start[i]).toUpperCase());
          }
          if (this.start.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("finish:");
      if (this.finish == null) {
        sb.append("null");
      } else {
          int __finish_size = Math.min(this.finish.length, 128);
          for (int i = 0; i < __finish_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.finish[i]).length() > 1 ? Integer.toHexString(this.finish[i]).substring(Integer.toHexString(this.finish[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.finish[i]).toUpperCase());
          }
          if (this.finish.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("is_ascending:");
      sb.append(this.is_ascending);
      first = false;
      if (!first) sb.append(", ");
      sb.append("count:");
      sb.append(this.count);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);

    public List<SuperColumn> success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, SuperColumn.class))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_result.class, metaDataMap);
    }

    public get_slice_super_result() {
    }

    public get_slice_super_result(
      List<SuperColumn> success,
      InvalidRequestException ire)
    {
      this();
      this.success = success;
      this.ire = ire;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_result(get_slice_super_result other) {
      if (other.isSetSuccess()) {
        List<SuperColumn> __this__success = new ArrayList<SuperColumn>();
        for (SuperColumn other_element : other.success) {
          __this__success.add(new SuperColumn(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
    }

    @Override
    public get_slice_super_result clone() {
      return new get_slice_super_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<SuperColumn> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(SuperColumn elem) {
      if (this.success == null) {
        this.success = new ArrayList<SuperColumn>();
      }
      this.success.add(elem);
    }

    public List<SuperColumn> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<SuperColumn> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<SuperColumn>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_result)
        return this.equals((get_slice_super_result)that);
      return false;
    }

    public boolean equals(get_slice_super_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list43 = iprot.readListBegin();
                this.success = new ArrayList<SuperColumn>(_list43.size);
                for (int _i44 = 0; _i44 < _list43.size; ++_i44)
                {
                  SuperColumn _elem45;
                  _elem45 = new SuperColumn();
                  _elem45.read(iprot);
                  this.success.add(_elem45);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (SuperColumn _iter46 : this.success)          {
            _iter46.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_by_names_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_by_names_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)3);
    private static final TField SUPER_COLUMN_NAMES_FIELD_DESC = new TField("super_column_names", TType.LIST, (short)4);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public String column_family;
    public static final int COLUMN_FAMILY = 3;
    public List<byte[]> super_column_names;
    public static final int SUPER_COLUMN_NAMES = 4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SUPER_COLUMN_NAMES, new FieldMetaData("super_column_names", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_by_names_args.class, metaDataMap);
    }

    public get_slice_super_by_names_args() {
    }

    public get_slice_super_by_names_args(
      String table,
      String key,
      String column_family,
      List<byte[]> super_column_names)
    {
      this();
      this.table = table;
      this.key = key;
      this.column_family = column_family;
      this.super_column_names = super_column_names;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_by_names_args(get_slice_super_by_names_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_family()) {
        this.column_family = other.column_family;
      }
      if (other.isSetSuper_column_names()) {
        List<byte[]> __this__super_column_names = new ArrayList<byte[]>();
        for (byte[] other_element : other.super_column_names) {
          byte[] temp_binary_element = new byte[other_element.length];
          System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
          __this__super_column_names.add(temp_binary_element);
        }
        this.super_column_names = __this__super_column_names;
      }
    }

    @Override
    public get_slice_super_by_names_args clone() {
      return new get_slice_super_by_names_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public String getColumn_family() {
      return this.column_family;
    }

    public void setColumn_family(String column_family) {
      this.column_family = column_family;
    }

    public void unsetColumn_family() {
      this.column_family = null;
    }

    // Returns true if field column_family is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_family() {
      return this.column_family != null;
    }

    public void setColumn_familyIsSet(boolean value) {
      if (!value) {
        this.column_family = null;
      }
    }

    public int getSuper_column_namesSize() {
      return (this.super_column_names == null) ? 0 : this.super_column_names.size();
    }

    public java.util.Iterator<byte[]> getSuper_column_namesIterator() {
      return (this.super_column_names == null) ? null : this.super_column_names.iterator();
    }

    public void addToSuper_column_names(byte[] elem) {
      if (this.super_column_names == null) {
        this.super_column_names = new ArrayList<byte[]>();
      }
      this.super_column_names.add(elem);
    }

    public List<byte[]> getSuper_column_names() {
      return this.super_column_names;
    }

    public void setSuper_column_names(List<byte[]> super_column_names) {
      this.super_column_names = super_column_names;
    }

    public void unsetSuper_column_names() {
      this.super_column_names = null;
    }

    // Returns true if field super_column_names is set (has been asigned a value) and false otherwise
    public boolean isSetSuper_column_names() {
      return this.super_column_names != null;
    }

    public void setSuper_column_namesIsSet(boolean value) {
      if (!value) {
        this.super_column_names = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_FAMILY:
        if (value == null) {
          unsetColumn_family();
        } else {
          setColumn_family((String)value);
        }
        break;

      case SUPER_COLUMN_NAMES:
        if (value == null) {
          unsetSuper_column_names();
        } else {
          setSuper_column_names((List<byte[]>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case COLUMN_FAMILY:
        return getColumn_family();

      case SUPER_COLUMN_NAMES:
        return getSuper_column_names();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case COLUMN_FAMILY:
        return isSetColumn_family();
      case SUPER_COLUMN_NAMES:
        return isSetSuper_column_names();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_by_names_args)
        return this.equals((get_slice_super_by_names_args)that);
      return false;
    }

    public boolean equals(get_slice_super_by_names_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_family = true && this.isSetColumn_family();
      boolean that_present_column_family = true && that.isSetColumn_family();
      if (this_present_column_family || that_present_column_family) {
        if (!(this_present_column_family && that_present_column_family))
          return false;
        if (!this.column_family.equals(that.column_family))
          return false;
      }

      boolean this_present_super_column_names = true && this.isSetSuper_column_names();
      boolean that_present_super_column_names = true && that.isSetSuper_column_names();
      if (this_present_super_column_names || that_present_super_column_names) {
        if (!(this_present_super_column_names && that_present_super_column_names))
          return false;
        if (!this.super_column_names.equals(that.super_column_names))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_FAMILY:
            if (field.type == TType.STRING) {
              this.column_family = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SUPER_COLUMN_NAMES:
            if (field.type == TType.LIST) {
              {
                TList _list47 = iprot.readListBegin();
                this.super_column_names = new ArrayList<byte[]>(_list47.size);
                for (int _i48 = 0; _i48 < _list47.size; ++_i48)
                {
                  byte[] _elem49;
                  _elem49 = iprot.readBinary();
                  this.super_column_names.add(_elem49);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_family != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
        oprot.writeString(this.column_family);
        oprot.writeFieldEnd();
      }
      if (this.super_column_names != null) {
        oprot.writeFieldBegin(SUPER_COLUMN_NAMES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.super_column_names.size()));
          for (byte[] _iter50 : this.super_column_names)          {
            oprot.writeBinary(_iter50);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_by_names_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_family:");
      if (this.column_family == null) {
        sb.append("null");
      } else {
        sb.append(this.column_family);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("super_column_names:");
      if (this.super_column_names == null) {
        sb.append("null");
      } else {
        sb.append(this.super_column_names);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_by_names_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_by_names_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);

    public List<SuperColumn> success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, SuperColumn.class))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_by_names_result.class, metaDataMap);
    }

    public get_slice_super_by_names_result() {
    }

    public get_slice_super_by_names_result(
      List<SuperColumn> success,
      InvalidRequestException ire)
    {
      this();
      this.success = success;
      this.ire = ire;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_by_names_result(get_slice_super_by_names_result other) {
      if (other.isSetSuccess()) {
        List<SuperColumn> __this__success = new ArrayList<SuperColumn>();
        for (SuperColumn other_element : other.success) {
          __this__success.add(new SuperColumn(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
    }

    @Override
    public get_slice_super_by_names_result clone() {
      return new get_slice_super_by_names_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<SuperColumn> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(SuperColumn elem) {
      if (this.success == null) {
        this.success = new ArrayList<SuperColumn>();
      }
      this.success.add(elem);
    }

    public List<SuperColumn> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<SuperColumn> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<SuperColumn>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_by_names_result)
        return this.equals((get_slice_super_by_names_result)that);
      return false;
    }

    public boolean equals(get_slice_super_by_names_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list51 = iprot.readListBegin();
                this.success = new ArrayList<SuperColumn>(_list51.size);
                for (int _i52 = 0; _i52 < _list51.size; ++_i52)
                {
                  SuperColumn _elem53;
                  _elem53 = new SuperColumn();
                  _elem53.read(iprot);
                  this.success.add(_elem53);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (SuperColumn _iter54 : this.success)          {
            _iter54.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_by_names_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_super_column_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_super_column_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField SUPER_COLUMN_PATH_FIELD_DESC = new TField("super_column_path", TType.STRUCT, (short)3);

    public String table;
    public static final int TABLE = 1;
    public String key;
    public static final int KEY = 2;
    public SuperColumnPath super_column_path;
    public static final int SUPER_COLUMN_PATH = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SUPER_COLUMN_PATH, new FieldMetaData("super_column_path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SuperColumnPath.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_super_column_args.class, metaDataMap);
    }

    public get_super_column_args() {
    }

    public get_super_column_args(
      String table,
      String key,
      SuperColumnPath super_column_path)
    {
      this();
      this.table = table;
      this.key = key;
      this.super_column_path = super_column_path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_super_column_args(get_super_column_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetSuper_column_path()) {
        this.super_column_path = new SuperColumnPath(other.super_column_path);
      }
    }

    @Override
    public get_super_column_args clone() {
      return new get_super_column_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public SuperColumnPath getSuper_column_path() {
      return this.super_column_path;
    }

    public void setSuper_column_path(SuperColumnPath super_column_path) {
      this.super_column_path = super_column_path;
    }

    public void unsetSuper_column_path() {
      this.super_column_path = null;
    }

    // Returns true if field super_column_path is set (has been asigned a value) and false otherwise
    public boolean isSetSuper_column_path() {
      return this.super_column_path != null;
    }

    public void setSuper_column_pathIsSet(boolean value) {
      if (!value) {
        this.super_column_path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case SUPER_COLUMN_PATH:
        if (value == null) {
          unsetSuper_column_path();
        } else {
          setSuper_column_path((SuperColumnPath)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case KEY:
        return getKey();

      case SUPER_COLUMN_PATH:
        return getSuper_column_path();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case KEY:
        return isSetKey();
      case SUPER_COLUMN_PATH:
        return isSetSuper_column_path();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_super_column_args)
        return this.equals((get_super_column_args)that);
      return false;
    }

    public boolean equals(get_super_column_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_super_column_path = true && this.isSetSuper_column_path();
      boolean that_present_super_column_path = true && that.isSetSuper_column_path();
      if (this_present_super_column_path || that_present_super_column_path) {
        if (!(this_present_super_column_path && that_present_super_column_path))
          return false;
        if (!this.super_column_path.equals(that.super_column_path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SUPER_COLUMN_PATH:
            if (field.type == TType.STRUCT) {
              this.super_column_path = new SuperColumnPath();
              this.super_column_path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.super_column_path != null) {
        oprot.writeFieldBegin(SUPER_COLUMN_PATH_FIELD_DESC);
        this.super_column_path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_super_column_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("super_column_path:");
      if (this.super_column_path == null) {
        sb.append("null");
      } else {
        sb.append(this.super_column_path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_super_column_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_super_column_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);

    public SuperColumn success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;
    public NotFoundException nfe;
    public static final int NFE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SuperColumn.class)));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_super_column_result.class, metaDataMap);
    }

    public get_super_column_result() {
    }

    public get_super_column_result(
      SuperColumn success,
      InvalidRequestException ire,
      NotFoundException nfe)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.nfe = nfe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_super_column_result(get_super_column_result other) {
      if (other.isSetSuccess()) {
        this.success = new SuperColumn(other.success);
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
    }

    @Override
    public get_super_column_result clone() {
      return new get_super_column_result(this);
    }

    public SuperColumn getSuccess() {
      return this.success;
    }

    public void setSuccess(SuperColumn success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public void setNfe(NotFoundException nfe) {
      this.nfe = nfe;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((SuperColumn)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case NFE:
        return getNfe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case NFE:
        return isSetNfe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_super_column_result)
        return this.equals((get_super_column_result)that);
      return false;
    }

    public boolean equals(get_super_column_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new SuperColumn();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_super_column_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_super_column_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_super_column_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField BATCH_MUTATION_SUPER_FIELD_DESC = new TField("batch_mutation_super", TType.STRUCT, (short)2);
    private static final TField BLOCK_FOR_FIELD_DESC = new TField("block_for", TType.I32, (short)3);

    public String table;
    public static final int TABLE = 1;
    public BatchMutationSuper batch_mutation_super;
    public static final int BATCH_MUTATION_SUPER = 2;
    public int block_for;
    public static final int BLOCK_FOR = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean block_for = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(BATCH_MUTATION_SUPER, new FieldMetaData("batch_mutation_super", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, BatchMutationSuper.class)));
      put(BLOCK_FOR, new FieldMetaData("block_for", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_super_column_args.class, metaDataMap);
    }

    public batch_insert_super_column_args() {
      this.block_for = 0;

    }

    public batch_insert_super_column_args(
      String table,
      BatchMutationSuper batch_mutation_super,
      int block_for)
    {
      this();
      this.table = table;
      this.batch_mutation_super = batch_mutation_super;
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_super_column_args(batch_insert_super_column_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetBatch_mutation_super()) {
        this.batch_mutation_super = new BatchMutationSuper(other.batch_mutation_super);
      }
      __isset.block_for = other.__isset.block_for;
      this.block_for = other.block_for;
    }

    @Override
    public batch_insert_super_column_args clone() {
      return new batch_insert_super_column_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public BatchMutationSuper getBatch_mutation_super() {
      return this.batch_mutation_super;
    }

    public void setBatch_mutation_super(BatchMutationSuper batch_mutation_super) {
      this.batch_mutation_super = batch_mutation_super;
    }

    public void unsetBatch_mutation_super() {
      this.batch_mutation_super = null;
    }

    // Returns true if field batch_mutation_super is set (has been asigned a value) and false otherwise
    public boolean isSetBatch_mutation_super() {
      return this.batch_mutation_super != null;
    }

    public void setBatch_mutation_superIsSet(boolean value) {
      if (!value) {
        this.batch_mutation_super = null;
      }
    }

    public int getBlock_for() {
      return this.block_for;
    }

    public void setBlock_for(int block_for) {
      this.block_for = block_for;
      this.__isset.block_for = true;
    }

    public void unsetBlock_for() {
      this.__isset.block_for = false;
    }

    // Returns true if field block_for is set (has been asigned a value) and false otherwise
    public boolean isSetBlock_for() {
      return this.__isset.block_for;
    }

    public void setBlock_forIsSet(boolean value) {
      this.__isset.block_for = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case BATCH_MUTATION_SUPER:
        if (value == null) {
          unsetBatch_mutation_super();
        } else {
          setBatch_mutation_super((BatchMutationSuper)value);
        }
        break;

      case BLOCK_FOR:
        if (value == null) {
          unsetBlock_for();
        } else {
          setBlock_for((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case BATCH_MUTATION_SUPER:
        return getBatch_mutation_super();

      case BLOCK_FOR:
        return new Integer(getBlock_for());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case BATCH_MUTATION_SUPER:
        return isSetBatch_mutation_super();
      case BLOCK_FOR:
        return isSetBlock_for();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_super_column_args)
        return this.equals((batch_insert_super_column_args)that);
      return false;
    }

    public boolean equals(batch_insert_super_column_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_batch_mutation_super = true && this.isSetBatch_mutation_super();
      boolean that_present_batch_mutation_super = true && that.isSetBatch_mutation_super();
      if (this_present_batch_mutation_super || that_present_batch_mutation_super) {
        if (!(this_present_batch_mutation_super && that_present_batch_mutation_super))
          return false;
        if (!this.batch_mutation_super.equals(that.batch_mutation_super))
          return false;
      }

      boolean this_present_block_for = true;
      boolean that_present_block_for = true;
      if (this_present_block_for || that_present_block_for) {
        if (!(this_present_block_for && that_present_block_for))
          return false;
        if (this.block_for != that.block_for)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BATCH_MUTATION_SUPER:
            if (field.type == TType.STRUCT) {
              this.batch_mutation_super = new BatchMutationSuper();
              this.batch_mutation_super.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BLOCK_FOR:
            if (field.type == TType.I32) {
              this.block_for = iprot.readI32();
              this.__isset.block_for = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.batch_mutation_super != null) {
        oprot.writeFieldBegin(BATCH_MUTATION_SUPER_FIELD_DESC);
        this.batch_mutation_super.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(BLOCK_FOR_FIELD_DESC);
      oprot.writeI32(this.block_for);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_super_column_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("batch_mutation_super:");
      if (this.batch_mutation_super == null) {
        sb.append("null");
      } else {
        sb.append(this.batch_mutation_super);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("block_for:");
      sb.append(this.block_for);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_super_column_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_super_column_result");
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public InvalidRequestException ire;
    public static final int IRE = 1;
    public UnavailableException ue;
    public static final int UE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_super_column_result.class, metaDataMap);
    }

    public batch_insert_super_column_result() {
    }

    public batch_insert_super_column_result(
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_super_column_result(batch_insert_super_column_result other) {
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    @Override
    public batch_insert_super_column_result clone() {
      return new batch_insert_super_column_result(this);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public void setUe(UnavailableException ue) {
      this.ue = ue;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_super_column_result)
        return this.equals((batch_insert_super_column_result)that);
      return false;
    }

    public boolean equals(batch_insert_super_column_result that) {
      if (that == null)
        return false;

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_super_column_result(");
      boolean first = true;

      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_key_range_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_key_range_args");
    private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
    private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)2);
    private static final TField START_WITH_FIELD_DESC = new TField("startWith", TType.STRING, (short)3);
    private static final TField STOP_AT_FIELD_DESC = new TField("stopAt", TType.STRING, (short)4);
    private static final TField MAX_RESULTS_FIELD_DESC = new TField("maxResults", TType.I32, (short)5);

    public String table;
    public static final int TABLE = 1;
    public String column_family;
    public static final int COLUMN_FAMILY = 2;
    public String startWith;
    public static final int STARTWITH = 3;
    public String stopAt;
    public static final int STOPAT = 4;
    public int maxResults;
    public static final int MAXRESULTS = 5;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean maxResults = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLE, new FieldMetaData("table", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(STARTWITH, new FieldMetaData("startWith", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(STOPAT, new FieldMetaData("stopAt", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(MAXRESULTS, new FieldMetaData("maxResults", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_key_range_args.class, metaDataMap);
    }

    public get_key_range_args() {
      this.startWith = "";

      this.stopAt = "";

      this.maxResults = 100;

    }

    public get_key_range_args(
      String table,
      String column_family,
      String startWith,
      String stopAt,
      int maxResults)
    {
      this();
      this.table = table;
      this.column_family = column_family;
      this.startWith = startWith;
      this.stopAt = stopAt;
      this.maxResults = maxResults;
      this.__isset.maxResults = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_key_range_args(get_key_range_args other) {
      if (other.isSetTable()) {
        this.table = other.table;
      }
      if (other.isSetColumn_family()) {
        this.column_family = other.column_family;
      }
      if (other.isSetStartWith()) {
        this.startWith = other.startWith;
      }
      if (other.isSetStopAt()) {
        this.stopAt = other.stopAt;
      }
      __isset.maxResults = other.__isset.maxResults;
      this.maxResults = other.maxResults;
    }

    @Override
    public get_key_range_args clone() {
      return new get_key_range_args(this);
    }

    public String getTable() {
      return this.table;
    }

    public void setTable(String table) {
      this.table = table;
    }

    public void unsetTable() {
      this.table = null;
    }

    // Returns true if field table is set (has been asigned a value) and false otherwise
    public boolean isSetTable() {
      return this.table != null;
    }

    public void setTableIsSet(boolean value) {
      if (!value) {
        this.table = null;
      }
    }

    public String getColumn_family() {
      return this.column_family;
    }

    public void setColumn_family(String column_family) {
      this.column_family = column_family;
    }

    public void unsetColumn_family() {
      this.column_family = null;
    }

    // Returns true if field column_family is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_family() {
      return this.column_family != null;
    }

    public void setColumn_familyIsSet(boolean value) {
      if (!value) {
        this.column_family = null;
      }
    }

    public String getStartWith() {
      return this.startWith;
    }

    public void setStartWith(String startWith) {
      this.startWith = startWith;
    }

    public void unsetStartWith() {
      this.startWith = null;
    }

    // Returns true if field startWith is set (has been asigned a value) and false otherwise
    public boolean isSetStartWith() {
      return this.startWith != null;
    }

    public void setStartWithIsSet(boolean value) {
      if (!value) {
        this.startWith = null;
      }
    }

    public String getStopAt() {
      return this.stopAt;
    }

    public void setStopAt(String stopAt) {
      this.stopAt = stopAt;
    }

    public void unsetStopAt() {
      this.stopAt = null;
    }

    // Returns true if field stopAt is set (has been asigned a value) and false otherwise
    public boolean isSetStopAt() {
      return this.stopAt != null;
    }

    public void setStopAtIsSet(boolean value) {
      if (!value) {
        this.stopAt = null;
      }
    }

    public int getMaxResults() {
      return this.maxResults;
    }

    public void setMaxResults(int maxResults) {
      this.maxResults = maxResults;
      this.__isset.maxResults = true;
    }

    public void unsetMaxResults() {
      this.__isset.maxResults = false;
    }

    // Returns true if field maxResults is set (has been asigned a value) and false otherwise
    public boolean isSetMaxResults() {
      return this.__isset.maxResults;
    }

    public void setMaxResultsIsSet(boolean value) {
      this.__isset.maxResults = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLE:
        if (value == null) {
          unsetTable();
        } else {
          setTable((String)value);
        }
        break;

      case COLUMN_FAMILY:
        if (value == null) {
          unsetColumn_family();
        } else {
          setColumn_family((String)value);
        }
        break;

      case STARTWITH:
        if (value == null) {
          unsetStartWith();
        } else {
          setStartWith((String)value);
        }
        break;

      case STOPAT:
        if (value == null) {
          unsetStopAt();
        } else {
          setStopAt((String)value);
        }
        break;

      case MAXRESULTS:
        if (value == null) {
          unsetMaxResults();
        } else {
          setMaxResults((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return getTable();

      case COLUMN_FAMILY:
        return getColumn_family();

      case STARTWITH:
        return getStartWith();

      case STOPAT:
        return getStopAt();

      case MAXRESULTS:
        return new Integer(getMaxResults());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLE:
        return isSetTable();
      case COLUMN_FAMILY:
        return isSetColumn_family();
      case STARTWITH:
        return isSetStartWith();
      case STOPAT:
        return isSetStopAt();
      case MAXRESULTS:
        return isSetMaxResults();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_key_range_args)
        return this.equals((get_key_range_args)that);
      return false;
    }

    public boolean equals(get_key_range_args that) {
      if (that == null)
        return false;

      boolean this_present_table = true && this.isSetTable();
      boolean that_present_table = true && that.isSetTable();
      if (this_present_table || that_present_table) {
        if (!(this_present_table && that_present_table))
          return false;
        if (!this.table.equals(that.table))
          return false;
      }

      boolean this_present_column_family = true && this.isSetColumn_family();
      boolean that_present_column_family = true && that.isSetColumn_family();
      if (this_present_column_family || that_present_column_family) {
        if (!(this_present_column_family && that_present_column_family))
          return false;
        if (!this.column_family.equals(that.column_family))
          return false;
      }

      boolean this_present_startWith = true && this.isSetStartWith();
      boolean that_present_startWith = true && that.isSetStartWith();
      if (this_present_startWith || that_present_startWith) {
        if (!(this_present_startWith && that_present_startWith))
          return false;
        if (!this.startWith.equals(that.startWith))
          return false;
      }

      boolean this_present_stopAt = true && this.isSetStopAt();
      boolean that_present_stopAt = true && that.isSetStopAt();
      if (this_present_stopAt || that_present_stopAt) {
        if (!(this_present_stopAt && that_present_stopAt))
          return false;
        if (!this.stopAt.equals(that.stopAt))
          return false;
      }

      boolean this_present_maxResults = true;
      boolean that_present_maxResults = true;
      if (this_present_maxResults || that_present_maxResults) {
        if (!(this_present_maxResults && that_present_maxResults))
          return false;
        if (this.maxResults != that.maxResults)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLE:
            if (field.type == TType.STRING) {
              this.table = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_FAMILY:
            if (field.type == TType.STRING) {
              this.column_family = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case STARTWITH:
            if (field.type == TType.STRING) {
              this.startWith = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case STOPAT:
            if (field.type == TType.STRING) {
              this.stopAt = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MAXRESULTS:
            if (field.type == TType.I32) {
              this.maxResults = iprot.readI32();
              this.__isset.maxResults = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.table != null) {
        oprot.writeFieldBegin(TABLE_FIELD_DESC);
        oprot.writeString(this.table);
        oprot.writeFieldEnd();
      }
      if (this.column_family != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
        oprot.writeString(this.column_family);
        oprot.writeFieldEnd();
      }
      if (this.startWith != null) {
        oprot.writeFieldBegin(START_WITH_FIELD_DESC);
        oprot.writeString(this.startWith);
        oprot.writeFieldEnd();
      }
      if (this.stopAt != null) {
        oprot.writeFieldBegin(STOP_AT_FIELD_DESC);
        oprot.writeString(this.stopAt);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_RESULTS_FIELD_DESC);
      oprot.writeI32(this.maxResults);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_key_range_args(");
      boolean first = true;

      sb.append("table:");
      if (this.table == null) {
        sb.append("null");
      } else {
        sb.append(this.table);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_family:");
      if (this.column_family == null) {
        sb.append("null");
      } else {
        sb.append(this.column_family);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("startWith:");
      if (this.startWith == null) {
        sb.append("null");
      } else {
        sb.append(this.startWith);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("stopAt:");
      if (this.stopAt == null) {
        sb.append("null");
      } else {
        sb.append(this.stopAt);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("maxResults:");
      sb.append(this.maxResults);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_key_range_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_key_range_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);

    public List<String> success;
    public static final int SUCCESS = 0;
    public InvalidRequestException ire;
    public static final int IRE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_key_range_result.class, metaDataMap);
    }

    public get_key_range_result() {
    }

    public get_key_range_result(
      List<String> success,
      InvalidRequestException ire)
    {
      this();
      this.success = success;
      this.ire = ire;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_key_range_result(get_key_range_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
    }

    @Override
    public get_key_range_result clone() {
      return new get_key_range_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public void setIre(InvalidRequestException ire) {
      this.ire = ire;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_key_range_result)
        return this.equals((get_key_range_result)that);
      return false;
    }

    public boolean equals(get_key_range_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list55 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list55.size);
                for (int _i56 = 0; _i56 < _list55.size; ++_i56)
                {
                  String _elem57;
                  _elem57 = iprot.readString();
                  this.success.add(_elem57);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter58 : this.success)          {
            oprot.writeString(_iter58);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_key_range_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringProperty_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringProperty_args");
    private static final TField PROPERTY_NAME_FIELD_DESC = new TField("propertyName", TType.STRING, (short)1);

    public String propertyName;
    public static final int PROPERTYNAME = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTYNAME, new FieldMetaData("propertyName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringProperty_args.class, metaDataMap);
    }

    public getStringProperty_args() {
    }

    public getStringProperty_args(
      String propertyName)
    {
      this();
      this.propertyName = propertyName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringProperty_args(getStringProperty_args other) {
      if (other.isSetPropertyName()) {
        this.propertyName = other.propertyName;
      }
    }

    @Override
    public getStringProperty_args clone() {
      return new getStringProperty_args(this);
    }

    public String getPropertyName() {
      return this.propertyName;
    }

    public void setPropertyName(String propertyName) {
      this.propertyName = propertyName;
    }

    public void unsetPropertyName() {
      this.propertyName = null;
    }

    // Returns true if field propertyName is set (has been asigned a value) and false otherwise
    public boolean isSetPropertyName() {
      return this.propertyName != null;
    }

    public void setPropertyNameIsSet(boolean value) {
      if (!value) {
        this.propertyName = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PROPERTYNAME:
        if (value == null) {
          unsetPropertyName();
        } else {
          setPropertyName((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return getPropertyName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return isSetPropertyName();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringProperty_args)
        return this.equals((getStringProperty_args)that);
      return false;
    }

    public boolean equals(getStringProperty_args that) {
      if (that == null)
        return false;

      boolean this_present_propertyName = true && this.isSetPropertyName();
      boolean that_present_propertyName = true && that.isSetPropertyName();
      if (this_present_propertyName || that_present_propertyName) {
        if (!(this_present_propertyName && that_present_propertyName))
          return false;
        if (!this.propertyName.equals(that.propertyName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PROPERTYNAME:
            if (field.type == TType.STRING) {
              this.propertyName = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.propertyName != null) {
        oprot.writeFieldBegin(PROPERTY_NAME_FIELD_DESC);
        oprot.writeString(this.propertyName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringProperty_args(");
      boolean first = true;

      sb.append("propertyName:");
      if (this.propertyName == null) {
        sb.append("null");
      } else {
        sb.append(this.propertyName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringProperty_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringProperty_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringProperty_result.class, metaDataMap);
    }

    public getStringProperty_result() {
    }

    public getStringProperty_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringProperty_result(getStringProperty_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    @Override
    public getStringProperty_result clone() {
      return new getStringProperty_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringProperty_result)
        return this.equals((getStringProperty_result)that);
      return false;
    }

    public boolean equals(getStringProperty_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringProperty_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringListProperty_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringListProperty_args");
    private static final TField PROPERTY_NAME_FIELD_DESC = new TField("propertyName", TType.STRING, (short)1);

    public String propertyName;
    public static final int PROPERTYNAME = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTYNAME, new FieldMetaData("propertyName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringListProperty_args.class, metaDataMap);
    }

    public getStringListProperty_args() {
    }

    public getStringListProperty_args(
      String propertyName)
    {
      this();
      this.propertyName = propertyName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringListProperty_args(getStringListProperty_args other) {
      if (other.isSetPropertyName()) {
        this.propertyName = other.propertyName;
      }
    }

    @Override
    public getStringListProperty_args clone() {
      return new getStringListProperty_args(this);
    }

    public String getPropertyName() {
      return this.propertyName;
    }

    public void setPropertyName(String propertyName) {
      this.propertyName = propertyName;
    }

    public void unsetPropertyName() {
      this.propertyName = null;
    }

    // Returns true if field propertyName is set (has been asigned a value) and false otherwise
    public boolean isSetPropertyName() {
      return this.propertyName != null;
    }

    public void setPropertyNameIsSet(boolean value) {
      if (!value) {
        this.propertyName = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PROPERTYNAME:
        if (value == null) {
          unsetPropertyName();
        } else {
          setPropertyName((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return getPropertyName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return isSetPropertyName();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringListProperty_args)
        return this.equals((getStringListProperty_args)that);
      return false;
    }

    public boolean equals(getStringListProperty_args that) {
      if (that == null)
        return false;

      boolean this_present_propertyName = true && this.isSetPropertyName();
      boolean that_present_propertyName = true && that.isSetPropertyName();
      if (this_present_propertyName || that_present_propertyName) {
        if (!(this_present_propertyName && that_present_propertyName))
          return false;
        if (!this.propertyName.equals(that.propertyName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PROPERTYNAME:
            if (field.type == TType.STRING) {
              this.propertyName = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.propertyName != null) {
        oprot.writeFieldBegin(PROPERTY_NAME_FIELD_DESC);
        oprot.writeString(this.propertyName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringListProperty_args(");
      boolean first = true;

      sb.append("propertyName:");
      if (this.propertyName == null) {
        sb.append("null");
      } else {
        sb.append(this.propertyName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringListProperty_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringListProperty_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringListProperty_result.class, metaDataMap);
    }

    public getStringListProperty_result() {
    }

    public getStringListProperty_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringListProperty_result(getStringListProperty_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    @Override
    public getStringListProperty_result clone() {
      return new getStringListProperty_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringListProperty_result)
        return this.equals((getStringListProperty_result)that);
      return false;
    }

    public boolean equals(getStringListProperty_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list59 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list59.size);
                for (int _i60 = 0; _i60 < _list59.size; ++_i60)
                {
                  String _elem61;
                  _elem61 = iprot.readString();
                  this.success.add(_elem61);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter62 : this.success)          {
            oprot.writeString(_iter62);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringListProperty_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class describeTable_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("describeTable_args");
    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    public String tableName;
    public static final int TABLENAME = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(describeTable_args.class, metaDataMap);
    }

    public describeTable_args() {
    }

    public describeTable_args(
      String tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public describeTable_args(describeTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    @Override
    public describeTable_args clone() {
      return new describeTable_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public void setTableName(String tableName) {
      this.tableName = tableName;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    // Returns true if field tableName is set (has been asigned a value) and false otherwise
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTableName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return isSetTableName();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof describeTable_args)
        return this.equals((describeTable_args)that);
      return false;
    }

    public boolean equals(describeTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tableName = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("describeTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class describeTable_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("describeTable_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)1);

    public Map<String,Map<String,String>> success;
    public static final int SUCCESS = 0;
    public NotFoundException nfe;
    public static final int NFE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new MapMetaData(TType.MAP, 
                  new FieldValueMetaData(TType.STRING), 
                  new FieldValueMetaData(TType.STRING)))));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(describeTable_result.class, metaDataMap);
    }

    public describeTable_result() {
    }

    public describeTable_result(
      Map<String,Map<String,String>> success,
      NotFoundException nfe)
    {
      this();
      this.success = success;
      this.nfe = nfe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public describeTable_result(describeTable_result other) {
      if (other.isSetSuccess()) {
        Map<String,Map<String,String>> __this__success = new HashMap<String,Map<String,String>>();
        for (Map.Entry<String, Map<String,String>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          Map<String,String> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          Map<String,String> __this__success_copy_value = new HashMap<String,String>();
          for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {

            String other_element_value_element_key = other_element_value_element.getKey();
            String other_element_value_element_value = other_element_value_element.getValue();

            String __this__success_copy_value_copy_key = other_element_value_element_key;

            String __this__success_copy_value_copy_value = other_element_value_element_value;

            __this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
          }

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
    }

    @Override
    public describeTable_result clone() {
      return new describeTable_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, Map<String,String> val) {
      if (this.success == null) {
        this.success = new HashMap<String,Map<String,String>>();
      }
      this.success.put(key, val);
    }

    public Map<String,Map<String,String>> getSuccess() {
      return this.success;
    }

    public void setSuccess(Map<String,Map<String,String>> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public void setNfe(NotFoundException nfe) {
      this.nfe = nfe;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,Map<String,String>>)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case NFE:
        return getNfe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case NFE:
        return isSetNfe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof describeTable_result)
        return this.equals((describeTable_result)that);
      return false;
    }

    public boolean equals(describeTable_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.MAP) {
              {
                TMap _map63 = iprot.readMapBegin();
                this.success = new HashMap<String,Map<String,String>>(2*_map63.size);
                for (int _i64 = 0; _i64 < _map63.size; ++_i64)
                {
                  String _key65;
                  Map<String,String> _val66;
                  _key65 = iprot.readString();
                  {
                    TMap _map67 = iprot.readMapBegin();
                    _val66 = new HashMap<String,String>(2*_map67.size);
                    for (int _i68 = 0; _i68 < _map67.size; ++_i68)
                    {
                      String _key69;
                      String _val70;
                      _key69 = iprot.readString();
                      _val70 = iprot.readString();
                      _val66.put(_key69, _val70);
                    }
                    iprot.readMapEnd();
                  }
                  this.success.put(_key65, _val66);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
          for (Map.Entry<String, Map<String,String>> _iter71 : this.success.entrySet())          {
            oprot.writeString(_iter71.getKey());
            {
              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter71.getValue().size()));
              for (Map.Entry<String, String> _iter72 : _iter71.getValue().entrySet())              {
                oprot.writeString(_iter72.getKey());
                oprot.writeString(_iter72.getValue());
              }
              oprot.writeMapEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("describeTable_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class executeQuery_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("executeQuery_args");
    private static final TField QUERY_FIELD_DESC = new TField("query", TType.STRING, (short)1);

    public String query;
    public static final int QUERY = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(QUERY, new FieldMetaData("query", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(executeQuery_args.class, metaDataMap);
    }

    public executeQuery_args() {
    }

    public executeQuery_args(
      String query)
    {
      this();
      this.query = query;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public executeQuery_args(executeQuery_args other) {
      if (other.isSetQuery()) {
        this.query = other.query;
      }
    }

    @Override
    public executeQuery_args clone() {
      return new executeQuery_args(this);
    }

    public String getQuery() {
      return this.query;
    }

    public void setQuery(String query) {
      this.query = query;
    }

    public void unsetQuery() {
      this.query = null;
    }

    // Returns true if field query is set (has been asigned a value) and false otherwise
    public boolean isSetQuery() {
      return this.query != null;
    }

    public void setQueryIsSet(boolean value) {
      if (!value) {
        this.query = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          setQuery((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return getQuery();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return isSetQuery();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof executeQuery_args)
        return this.equals((executeQuery_args)that);
      return false;
    }

    public boolean equals(executeQuery_args that) {
      if (that == null)
        return false;

      boolean this_present_query = true && this.isSetQuery();
      boolean that_present_query = true && that.isSetQuery();
      if (this_present_query || that_present_query) {
        if (!(this_present_query && that_present_query))
          return false;
        if (!this.query.equals(that.query))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case QUERY:
            if (field.type == TType.STRING) {
              this.query = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.query != null) {
        oprot.writeFieldBegin(QUERY_FIELD_DESC);
        oprot.writeString(this.query);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("executeQuery_args(");
      boolean first = true;

      sb.append("query:");
      if (this.query == null) {
        sb.append("null");
      } else {
        sb.append(this.query);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class executeQuery_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("executeQuery_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public CqlResult success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CqlResult.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(executeQuery_result.class, metaDataMap);
    }

    public executeQuery_result() {
    }

    public executeQuery_result(
      CqlResult success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public executeQuery_result(executeQuery_result other) {
      if (other.isSetSuccess()) {
        this.success = new CqlResult(other.success);
      }
    }

    @Override
    public executeQuery_result clone() {
      return new executeQuery_result(this);
    }

    public CqlResult getSuccess() {
      return this.success;
    }

    public void setSuccess(CqlResult success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((CqlResult)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof executeQuery_result)
        return this.equals((executeQuery_result)that);
      return false;
    }

    public boolean equals(executeQuery_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new CqlResult();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("executeQuery_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
