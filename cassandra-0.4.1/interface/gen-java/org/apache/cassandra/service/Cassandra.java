/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.cassandra.service;
/*
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 */


import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class Cassandra {

  public interface Iface {

    public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException;

    public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException;

    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, UnavailableException, TException;

    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, UnavailableException, TException;

    public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, UnavailableException, TException;

    public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, UnavailableException, TException;

    public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;

    public void batch_insert(String keyspace, String key, Map<String,List<ColumnOrSuperColumn>> cfmap, int consistency_level) throws InvalidRequestException, UnavailableException, TException;

    public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;

    public String get_string_property(String property) throws TException;

    public List<String> get_string_list_property(String property) throws TException;

    public Map<String,Map<String,String>> describe_keyspace(String keyspace) throws NotFoundException, TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException
    {
      send_get(keyspace, key, column_path, consistency_level);
      return recv_get();
    }

    public void send_get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
      get_args args = new get_args();
      args.keyspace = keyspace;
      args.key = key;
      args.column_path = column_path;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ColumnOrSuperColumn recv_get() throws InvalidRequestException, NotFoundException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException
    {
      send_get_slice(keyspace, key, column_parent, predicate, consistency_level);
      return recv_get_slice();
    }

    public void send_get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice", TMessageType.CALL, seqid_));
      get_slice_args args = new get_slice_args();
      args.keyspace = keyspace;
      args.key = key;
      args.column_parent = column_parent;
      args.predicate = predicate;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<ColumnOrSuperColumn> recv_get_slice() throws InvalidRequestException, NotFoundException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_result result = new get_slice_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
    }

    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, UnavailableException, TException
    {
      send_multiget(keyspace, keys, column_path, consistency_level);
      return recv_multiget();
    }

    public void send_multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("multiget", TMessageType.CALL, seqid_));
      multiget_args args = new multiget_args();
      args.keyspace = keyspace;
      args.keys = keys;
      args.column_path = column_path;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,ColumnOrSuperColumn> recv_multiget() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiget_result result = new multiget_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget failed: unknown result");
    }

    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, UnavailableException, TException
    {
      send_multiget_slice(keyspace, keys, column_parent, predicate, consistency_level);
      return recv_multiget_slice();
    }

    public void send_multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("multiget_slice", TMessageType.CALL, seqid_));
      multiget_slice_args args = new multiget_slice_args();
      args.keyspace = keyspace;
      args.keys = keys;
      args.column_parent = column_parent;
      args.predicate = predicate;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,List<ColumnOrSuperColumn>> recv_multiget_slice() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      multiget_slice_result result = new multiget_slice_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget_slice failed: unknown result");
    }

    public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, UnavailableException, TException
    {
      send_get_count(keyspace, key, column_parent, consistency_level);
      return recv_get_count();
    }

    public void send_get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_count", TMessageType.CALL, seqid_));
      get_count_args args = new get_count_args();
      args.keyspace = keyspace;
      args.key = key;
      args.column_parent = column_parent;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_get_count() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_count_result result = new get_count_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_count failed: unknown result");
    }

    public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, UnavailableException, TException
    {
      send_get_key_range(keyspace, column_family, start, finish, count, consistency_level);
      return recv_get_key_range();
    }

    public void send_get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_key_range", TMessageType.CALL, seqid_));
      get_key_range_args args = new get_key_range_args();
      args.keyspace = keyspace;
      args.column_family = column_family;
      args.start = start;
      args.finish = finish;
      args.count = count;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_key_range() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_key_range_result result = new get_key_range_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_key_range failed: unknown result");
    }

    public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException
    {
      send_insert(keyspace, key, column_path, value, timestamp, consistency_level);
      recv_insert();
    }

    public void send_insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("insert", TMessageType.CALL, seqid_));
      insert_args args = new insert_args();
      args.keyspace = keyspace;
      args.key = key;
      args.column_path = column_path;
      args.value = value;
      args.timestamp = timestamp;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_insert() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      insert_result result = new insert_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      return;
    }

    public void batch_insert(String keyspace, String key, Map<String,List<ColumnOrSuperColumn>> cfmap, int consistency_level) throws InvalidRequestException, UnavailableException, TException
    {
      send_batch_insert(keyspace, key, cfmap, consistency_level);
      recv_batch_insert();
    }

    public void send_batch_insert(String keyspace, String key, Map<String,List<ColumnOrSuperColumn>> cfmap, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("batch_insert", TMessageType.CALL, seqid_));
      batch_insert_args args = new batch_insert_args();
      args.keyspace = keyspace;
      args.key = key;
      args.cfmap = cfmap;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_batch_insert() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      batch_insert_result result = new batch_insert_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      return;
    }

    public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException
    {
      send_remove(keyspace, key, column_path, timestamp, consistency_level);
      recv_remove();
    }

    public void send_remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.keyspace = keyspace;
      args.key = key;
      args.column_path = column_path;
      args.timestamp = timestamp;
      args.consistency_level = consistency_level;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_remove() throws InvalidRequestException, UnavailableException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ire != null) {
        throw result.ire;
      }
      if (result.ue != null) {
        throw result.ue;
      }
      return;
    }

    public String get_string_property(String property) throws TException
    {
      send_get_string_property(property);
      return recv_get_string_property();
    }

    public void send_get_string_property(String property) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_string_property", TMessageType.CALL, seqid_));
      get_string_property_args args = new get_string_property_args();
      args.property = property;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_get_string_property() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_string_property_result result = new get_string_property_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_string_property failed: unknown result");
    }

    public List<String> get_string_list_property(String property) throws TException
    {
      send_get_string_list_property(property);
      return recv_get_string_list_property();
    }

    public void send_get_string_list_property(String property) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_string_list_property", TMessageType.CALL, seqid_));
      get_string_list_property_args args = new get_string_list_property_args();
      args.property = property;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_get_string_list_property() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_string_list_property_result result = new get_string_list_property_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_string_list_property failed: unknown result");
    }

    public Map<String,Map<String,String>> describe_keyspace(String keyspace) throws NotFoundException, TException
    {
      send_describe_keyspace(keyspace);
      return recv_describe_keyspace();
    }

    public void send_describe_keyspace(String keyspace) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.CALL, seqid_));
      describe_keyspace_args args = new describe_keyspace_args();
      args.keyspace = keyspace;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,Map<String,String>> recv_describe_keyspace() throws NotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      describe_keyspace_result result = new describe_keyspace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.nfe != null) {
        throw result.nfe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_keyspace failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("get", new get());
      processMap_.put("get_slice", new get_slice());
      processMap_.put("multiget", new multiget());
      processMap_.put("multiget_slice", new multiget_slice());
      processMap_.put("get_count", new get_count());
      processMap_.put("get_key_range", new get_key_range());
      processMap_.put("insert", new insert());
      processMap_.put("batch_insert", new batch_insert());
      processMap_.put("remove", new remove());
      processMap_.put("get_string_property", new get_string_property());
      processMap_.put("get_string_list_property", new get_string_list_property());
      processMap_.put("describe_keyspace", new describe_keyspace());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_args args = new get_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_result result = new get_result();
        try {
          result.success = iface_.get(args.keyspace, args.key, args.column_path, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
          oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_slice implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_args args = new get_slice_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_result result = new get_slice_result();
        try {
          result.success = iface_.get_slice(args.keyspace, args.key, args.column_parent, args.predicate, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_slice", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice");
          oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class multiget implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        multiget_args args = new multiget_args();
        args.read(iprot);
        iprot.readMessageEnd();
        multiget_result result = new multiget_result();
        try {
          result.success = iface_.multiget(args.keyspace, args.keys, args.column_path, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing multiget", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget");
          oprot.writeMessageBegin(new TMessage("multiget", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("multiget", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class multiget_slice implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        multiget_slice_args args = new multiget_slice_args();
        args.read(iprot);
        iprot.readMessageEnd();
        multiget_slice_result result = new multiget_slice_result();
        try {
          result.success = iface_.multiget_slice(args.keyspace, args.keys, args.column_parent, args.predicate, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing multiget_slice", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget_slice");
          oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("multiget_slice", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_count implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_count_args args = new get_count_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_count_result result = new get_count_result();
        try {
          result.success = iface_.get_count(args.keyspace, args.key, args.column_parent, args.consistency_level);
          result.setSuccessIsSet(true);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_count", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_count");
          oprot.writeMessageBegin(new TMessage("get_count", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_count", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_key_range implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_key_range_args args = new get_key_range_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_key_range_result result = new get_key_range_result();
        try {
          result.success = iface_.get_key_range(args.keyspace, args.column_family, args.start, args.finish, args.count, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_key_range", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_key_range");
          oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_key_range", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class insert implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        insert_args args = new insert_args();
        args.read(iprot);
        iprot.readMessageEnd();
        insert_result result = new insert_result();
        try {
          iface_.insert(args.keyspace, args.key, args.column_path, args.value, args.timestamp, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing insert", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing insert");
          oprot.writeMessageBegin(new TMessage("insert", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("insert", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class batch_insert implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        batch_insert_args args = new batch_insert_args();
        args.read(iprot);
        iprot.readMessageEnd();
        batch_insert_result result = new batch_insert_result();
        try {
          iface_.batch_insert(args.keyspace, args.key, args.cfmap, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing batch_insert", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_insert");
          oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("batch_insert", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        remove_args args = new remove_args();
        args.read(iprot);
        iprot.readMessageEnd();
        remove_result result = new remove_result();
        try {
          iface_.remove(args.keyspace, args.key, args.column_path, args.timestamp, args.consistency_level);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        } catch (UnavailableException ue) {
          result.ue = ue;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing remove", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing remove");
          oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_string_property implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_string_property_args args = new get_string_property_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_string_property_result result = new get_string_property_result();
        result.success = iface_.get_string_property(args.property);
        oprot.writeMessageBegin(new TMessage("get_string_property", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_string_list_property implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_string_list_property_args args = new get_string_list_property_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_string_list_property_result result = new get_string_list_property_result();
        result.success = iface_.get_string_list_property(args.property);
        oprot.writeMessageBegin(new TMessage("get_string_list_property", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class describe_keyspace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        describe_keyspace_args args = new describe_keyspace_args();
        args.read(iprot);
        iprot.readMessageEnd();
        describe_keyspace_result result = new describe_keyspace_result();
        try {
          result.success = iface_.describe_keyspace(args.keyspace);
        } catch (NotFoundException nfe) {
          result.nfe = nfe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing describe_keyspace", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing describe_keyspace");
          oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("describe_keyspace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class get_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);

    public String keyspace;
    public String key;
    public ColumnPath column_path;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEY = 2;
    public static final int COLUMN_PATH = 3;
    public static final int CONSISTENCY_LEVEL = 4;

    // isset id assignments
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnPath.class)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
      this.consistency_level = 1;

    }

    public get_args(
      String keyspace,
      String key,
      ColumnPath column_path,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.key = key;
      this.column_path = column_path;
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_path()) {
        this.column_path = new ColumnPath(other.column_path);
      }
      this.consistency_level = other.consistency_level;
    }

    public get_args deepCopy() {
      return new get_args(this);
    }

    @Deprecated
    public get_args clone() {
      return new get_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public get_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public get_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnPath getColumn_path() {
      return this.column_path;
    }

    public get_args setColumn_path(ColumnPath column_path) {
      this.column_path = column_path;
      return this;
    }

    public void unsetColumn_path() {
      this.column_path = null;
    }

    // Returns true if field column_path is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path() {
      return this.column_path != null;
    }

    public void setColumn_pathIsSet(boolean value) {
      if (!value) {
        this.column_path = null;
      }
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public get_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PATH:
        if (value == null) {
          unsetColumn_path();
        } else {
          setColumn_path((ColumnPath)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEY:
        return getKey();

      case COLUMN_PATH:
        return getColumn_path();

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEY:
        return isSetKey();
      case COLUMN_PATH:
        return isSetColumn_path();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_args)
        return this.equals((get_args)that);
      return false;
    }

    public boolean equals(get_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_path = true && this.isSetColumn_path();
      boolean that_present_column_path = true && that.isSetColumn_path();
      if (this_present_column_path || that_present_column_path) {
        if (!(this_present_column_path && that_present_column_path))
          return false;
        if (!this.column_path.equals(that.column_path))
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_args typedOther = (get_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PATH:
            if (field.type == TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_path != null) {
        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
        this.column_path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_path:");
      if (this.column_path == null) {
        sb.append("null");
      } else {
        sb.append(this.column_path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (key == null) {
        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
      }
      if (column_path == null) {
        throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class get_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)3);

    public ColumnOrSuperColumn success;
    public InvalidRequestException ire;
    public NotFoundException nfe;
    public UnavailableException ue;
    public static final int SUCCESS = 0;
    public static final int IRE = 1;
    public static final int NFE = 2;
    public static final int UE = 3;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
      ColumnOrSuperColumn success,
      InvalidRequestException ire,
      NotFoundException nfe,
      UnavailableException ue)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.nfe = nfe;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        this.success = new ColumnOrSuperColumn(other.success);
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public get_result deepCopy() {
      return new get_result(this);
    }

    @Deprecated
    public get_result clone() {
      return new get_result(this);
    }

    public ColumnOrSuperColumn getSuccess() {
      return this.success;
    }

    public get_result setSuccess(ColumnOrSuperColumn success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public get_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public get_result setNfe(NotFoundException nfe) {
      this.nfe = nfe;
      return this;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public get_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ColumnOrSuperColumn)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case NFE:
        return getNfe();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case NFE:
        return isSetNfe();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_result)
        return this.equals((get_result)that);
      return false;
    }

    public boolean equals(get_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_result typedOther = (get_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetNfe()).compareTo(isSetNfe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(nfe, typedOther.nfe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ColumnOrSuperColumn();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_slice_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
    private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);

    public String keyspace;
    public String key;
    public ColumnParent column_parent;
    public SlicePredicate predicate;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEY = 2;
    public static final int COLUMN_PARENT = 3;
    public static final int PREDICATE = 4;
    public static final int CONSISTENCY_LEVEL = 5;

    // isset id assignments
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnParent.class)));
      put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, SlicePredicate.class)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_args.class, metaDataMap);
    }

    public get_slice_args() {
      this.consistency_level = 1;

    }

    public get_slice_args(
      String keyspace,
      String key,
      ColumnParent column_parent,
      SlicePredicate predicate,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.key = key;
      this.column_parent = column_parent;
      this.predicate = predicate;
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_args(get_slice_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_parent()) {
        this.column_parent = new ColumnParent(other.column_parent);
      }
      if (other.isSetPredicate()) {
        this.predicate = new SlicePredicate(other.predicate);
      }
      this.consistency_level = other.consistency_level;
    }

    public get_slice_args deepCopy() {
      return new get_slice_args(this);
    }

    @Deprecated
    public get_slice_args clone() {
      return new get_slice_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public get_slice_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public get_slice_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
    }

    public get_slice_args setColumn_parent(ColumnParent column_parent) {
      this.column_parent = column_parent;
      return this;
    }

    public void unsetColumn_parent() {
      this.column_parent = null;
    }

    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_parent() {
      return this.column_parent != null;
    }

    public void setColumn_parentIsSet(boolean value) {
      if (!value) {
        this.column_parent = null;
      }
    }

    public SlicePredicate getPredicate() {
      return this.predicate;
    }

    public get_slice_args setPredicate(SlicePredicate predicate) {
      this.predicate = predicate;
      return this;
    }

    public void unsetPredicate() {
      this.predicate = null;
    }

    // Returns true if field predicate is set (has been asigned a value) and false otherwise
    public boolean isSetPredicate() {
      return this.predicate != null;
    }

    public void setPredicateIsSet(boolean value) {
      if (!value) {
        this.predicate = null;
      }
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public get_slice_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PARENT:
        if (value == null) {
          unsetColumn_parent();
        } else {
          setColumn_parent((ColumnParent)value);
        }
        break;

      case PREDICATE:
        if (value == null) {
          unsetPredicate();
        } else {
          setPredicate((SlicePredicate)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEY:
        return getKey();

      case COLUMN_PARENT:
        return getColumn_parent();

      case PREDICATE:
        return getPredicate();

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEY:
        return isSetKey();
      case COLUMN_PARENT:
        return isSetColumn_parent();
      case PREDICATE:
        return isSetPredicate();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_args)
        return this.equals((get_slice_args)that);
      return false;
    }

    public boolean equals(get_slice_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_parent = true && this.isSetColumn_parent();
      boolean that_present_column_parent = true && that.isSetColumn_parent();
      if (this_present_column_parent || that_present_column_parent) {
        if (!(this_present_column_parent && that_present_column_parent))
          return false;
        if (!this.column_parent.equals(that.column_parent))
          return false;
      }

      boolean this_present_predicate = true && this.isSetPredicate();
      boolean that_present_predicate = true && that.isSetPredicate();
      if (this_present_predicate || that_present_predicate) {
        if (!(this_present_predicate && that_present_predicate))
          return false;
        if (!this.predicate.equals(that.predicate))
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_slice_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_slice_args typedOther = (get_slice_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(isSetPredicate());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PARENT:
            if (field.type == TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case PREDICATE:
            if (field.type == TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_parent != null) {
        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
        this.column_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.predicate != null) {
        oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
        this.predicate.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_parent:");
      if (this.column_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_parent);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("predicate:");
      if (this.predicate == null) {
        sb.append("null");
      } else {
        sb.append(this.predicate);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (key == null) {
        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
      }
      if (column_parent == null) {
        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
      }
      if (predicate == null) {
        throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class get_slice_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_slice_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)3);

    public List<ColumnOrSuperColumn> success;
    public InvalidRequestException ire;
    public NotFoundException nfe;
    public UnavailableException ue;
    public static final int SUCCESS = 0;
    public static final int IRE = 1;
    public static final int NFE = 2;
    public static final int UE = 3;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_result.class, metaDataMap);
    }

    public get_slice_result() {
    }

    public get_slice_result(
      List<ColumnOrSuperColumn> success,
      InvalidRequestException ire,
      NotFoundException nfe,
      UnavailableException ue)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.nfe = nfe;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_result(get_slice_result other) {
      if (other.isSetSuccess()) {
        List<ColumnOrSuperColumn> __this__success = new ArrayList<ColumnOrSuperColumn>();
        for (ColumnOrSuperColumn other_element : other.success) {
          __this__success.add(new ColumnOrSuperColumn(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public get_slice_result deepCopy() {
      return new get_slice_result(this);
    }

    @Deprecated
    public get_slice_result clone() {
      return new get_slice_result(this);
    }

    public List<ColumnOrSuperColumn> getSuccess() {
      return this.success;
    }

    public get_slice_result setSuccess(List<ColumnOrSuperColumn> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public get_slice_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public get_slice_result setNfe(NotFoundException nfe) {
      this.nfe = nfe;
      return this;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public get_slice_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<ColumnOrSuperColumn>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case NFE:
        return getNfe();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case NFE:
        return isSetNfe();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_result)
        return this.equals((get_slice_result)that);
      return false;
    }

    public boolean equals(get_slice_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_slice_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_slice_result typedOther = (get_slice_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetNfe()).compareTo(isSetNfe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(nfe, typedOther.nfe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list8 = iprot.readListBegin();
                this.success = new ArrayList<ColumnOrSuperColumn>(_list8.size);
                for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                {
                  ColumnOrSuperColumn _elem10;
                  _elem10 = new ColumnOrSuperColumn();
                  _elem10.read(iprot);
                  this.success.add(_elem10);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (ColumnOrSuperColumn _iter11 : this.success)
          {
            _iter11.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiget_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiget_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiget_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);

    public String keyspace;
    public List<String> keys;
    public ColumnPath column_path;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEYS = 2;
    public static final int COLUMN_PATH = 3;
    public static final int CONSISTENCY_LEVEL = 4;

    // isset id assignments
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEYS, new FieldMetaData("keys", TFieldRequirementType.REQUIRED, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnPath.class)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(multiget_args.class, metaDataMap);
    }

    public multiget_args() {
      this.consistency_level = 1;

    }

    public multiget_args(
      String keyspace,
      List<String> keys,
      ColumnPath column_path,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.keys = keys;
      this.column_path = column_path;
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiget_args(multiget_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKeys()) {
        List<String> __this__keys = new ArrayList<String>();
        for (String other_element : other.keys) {
          __this__keys.add(other_element);
        }
        this.keys = __this__keys;
      }
      if (other.isSetColumn_path()) {
        this.column_path = new ColumnPath(other.column_path);
      }
      this.consistency_level = other.consistency_level;
    }

    public multiget_args deepCopy() {
      return new multiget_args(this);
    }

    @Deprecated
    public multiget_args clone() {
      return new multiget_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public multiget_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public List<String> getKeys() {
      return this.keys;
    }

    public multiget_args setKeys(List<String> keys) {
      this.keys = keys;
      return this;
    }

    public void unsetKeys() {
      this.keys = null;
    }

    // Returns true if field keys is set (has been asigned a value) and false otherwise
    public boolean isSetKeys() {
      return this.keys != null;
    }

    public void setKeysIsSet(boolean value) {
      if (!value) {
        this.keys = null;
      }
    }

    public ColumnPath getColumn_path() {
      return this.column_path;
    }

    public multiget_args setColumn_path(ColumnPath column_path) {
      this.column_path = column_path;
      return this;
    }

    public void unsetColumn_path() {
      this.column_path = null;
    }

    // Returns true if field column_path is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path() {
      return this.column_path != null;
    }

    public void setColumn_pathIsSet(boolean value) {
      if (!value) {
        this.column_path = null;
      }
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public multiget_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEYS:
        if (value == null) {
          unsetKeys();
        } else {
          setKeys((List<String>)value);
        }
        break;

      case COLUMN_PATH:
        if (value == null) {
          unsetColumn_path();
        } else {
          setColumn_path((ColumnPath)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEYS:
        return getKeys();

      case COLUMN_PATH:
        return getColumn_path();

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEYS:
        return isSetKeys();
      case COLUMN_PATH:
        return isSetColumn_path();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiget_args)
        return this.equals((multiget_args)that);
      return false;
    }

    public boolean equals(multiget_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_keys = true && this.isSetKeys();
      boolean that_present_keys = true && that.isSetKeys();
      if (this_present_keys || that_present_keys) {
        if (!(this_present_keys && that_present_keys))
          return false;
        if (!this.keys.equals(that.keys))
          return false;
      }

      boolean this_present_column_path = true && this.isSetColumn_path();
      boolean that_present_column_path = true && that.isSetColumn_path();
      if (this_present_column_path || that_present_column_path) {
        if (!(this_present_column_path && that_present_column_path))
          return false;
        if (!this.column_path.equals(that.column_path))
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(multiget_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      multiget_args typedOther = (multiget_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetKeys()).compareTo(isSetKeys());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEYS:
            if (field.type == TType.LIST) {
              {
                TList _list12 = iprot.readListBegin();
                this.keys = new ArrayList<String>(_list12.size);
                for (int _i13 = 0; _i13 < _list12.size; ++_i13)
                {
                  String _elem14;
                  _elem14 = iprot.readString();
                  this.keys.add(_elem14);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PATH:
            if (field.type == TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.keys != null) {
        oprot.writeFieldBegin(KEYS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
          for (String _iter15 : this.keys)
          {
            oprot.writeString(_iter15);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.column_path != null) {
        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
        this.column_path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiget_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keys:");
      if (this.keys == null) {
        sb.append("null");
      } else {
        sb.append(this.keys);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_path:");
      if (this.column_path == null) {
        sb.append("null");
      } else {
        sb.append(this.column_path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (keys == null) {
        throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
      }
      if (column_path == null) {
        throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class multiget_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("multiget_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public Map<String,ColumnOrSuperColumn> success;
    public InvalidRequestException ire;
    public UnavailableException ue;
    public static final int SUCCESS = 0;
    public static final int IRE = 1;
    public static final int UE = 2;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(multiget_result.class, metaDataMap);
    }

    public multiget_result() {
    }

    public multiget_result(
      Map<String,ColumnOrSuperColumn> success,
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiget_result(multiget_result other) {
      if (other.isSetSuccess()) {
        Map<String,ColumnOrSuperColumn> __this__success = new HashMap<String,ColumnOrSuperColumn>();
        for (Map.Entry<String, ColumnOrSuperColumn> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          ColumnOrSuperColumn other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          ColumnOrSuperColumn __this__success_copy_value = new ColumnOrSuperColumn(other_element_value);

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public multiget_result deepCopy() {
      return new multiget_result(this);
    }

    @Deprecated
    public multiget_result clone() {
      return new multiget_result(this);
    }

    public Map<String,ColumnOrSuperColumn> getSuccess() {
      return this.success;
    }

    public multiget_result setSuccess(Map<String,ColumnOrSuperColumn> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public multiget_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public multiget_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,ColumnOrSuperColumn>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiget_result)
        return this.equals((multiget_result)that);
      return false;
    }

    public boolean equals(multiget_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.MAP) {
              {
                TMap _map16 = iprot.readMapBegin();
                this.success = new HashMap<String,ColumnOrSuperColumn>(2*_map16.size);
                for (int _i17 = 0; _i17 < _map16.size; ++_i17)
                {
                  String _key18;
                  ColumnOrSuperColumn _val19;
                  _key18 = iprot.readString();
                  _val19 = new ColumnOrSuperColumn();
                  _val19.read(iprot);
                  this.success.put(_key18, _val19);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
          for (Map.Entry<String, ColumnOrSuperColumn> _iter20 : this.success.entrySet())
          {
            oprot.writeString(_iter20.getKey());
            _iter20.getValue().write(oprot);
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiget_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class multiget_slice_args implements TBase, java.io.Serializable, Cloneable, Comparable<multiget_slice_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)2);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
    private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)4);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);

    public String keyspace;
    public List<String> keys;
    public ColumnParent column_parent;
    public SlicePredicate predicate;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEYS = 2;
    public static final int COLUMN_PARENT = 3;
    public static final int PREDICATE = 4;
    public static final int CONSISTENCY_LEVEL = 5;

    // isset id assignments
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEYS, new FieldMetaData("keys", TFieldRequirementType.REQUIRED, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnParent.class)));
      put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, SlicePredicate.class)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(multiget_slice_args.class, metaDataMap);
    }

    public multiget_slice_args() {
      this.consistency_level = 1;

    }

    public multiget_slice_args(
      String keyspace,
      List<String> keys,
      ColumnParent column_parent,
      SlicePredicate predicate,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.keys = keys;
      this.column_parent = column_parent;
      this.predicate = predicate;
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiget_slice_args(multiget_slice_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKeys()) {
        List<String> __this__keys = new ArrayList<String>();
        for (String other_element : other.keys) {
          __this__keys.add(other_element);
        }
        this.keys = __this__keys;
      }
      if (other.isSetColumn_parent()) {
        this.column_parent = new ColumnParent(other.column_parent);
      }
      if (other.isSetPredicate()) {
        this.predicate = new SlicePredicate(other.predicate);
      }
      this.consistency_level = other.consistency_level;
    }

    public multiget_slice_args deepCopy() {
      return new multiget_slice_args(this);
    }

    @Deprecated
    public multiget_slice_args clone() {
      return new multiget_slice_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public multiget_slice_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public List<String> getKeys() {
      return this.keys;
    }

    public multiget_slice_args setKeys(List<String> keys) {
      this.keys = keys;
      return this;
    }

    public void unsetKeys() {
      this.keys = null;
    }

    // Returns true if field keys is set (has been asigned a value) and false otherwise
    public boolean isSetKeys() {
      return this.keys != null;
    }

    public void setKeysIsSet(boolean value) {
      if (!value) {
        this.keys = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
    }

    public multiget_slice_args setColumn_parent(ColumnParent column_parent) {
      this.column_parent = column_parent;
      return this;
    }

    public void unsetColumn_parent() {
      this.column_parent = null;
    }

    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_parent() {
      return this.column_parent != null;
    }

    public void setColumn_parentIsSet(boolean value) {
      if (!value) {
        this.column_parent = null;
      }
    }

    public SlicePredicate getPredicate() {
      return this.predicate;
    }

    public multiget_slice_args setPredicate(SlicePredicate predicate) {
      this.predicate = predicate;
      return this;
    }

    public void unsetPredicate() {
      this.predicate = null;
    }

    // Returns true if field predicate is set (has been asigned a value) and false otherwise
    public boolean isSetPredicate() {
      return this.predicate != null;
    }

    public void setPredicateIsSet(boolean value) {
      if (!value) {
        this.predicate = null;
      }
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public multiget_slice_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEYS:
        if (value == null) {
          unsetKeys();
        } else {
          setKeys((List<String>)value);
        }
        break;

      case COLUMN_PARENT:
        if (value == null) {
          unsetColumn_parent();
        } else {
          setColumn_parent((ColumnParent)value);
        }
        break;

      case PREDICATE:
        if (value == null) {
          unsetPredicate();
        } else {
          setPredicate((SlicePredicate)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEYS:
        return getKeys();

      case COLUMN_PARENT:
        return getColumn_parent();

      case PREDICATE:
        return getPredicate();

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEYS:
        return isSetKeys();
      case COLUMN_PARENT:
        return isSetColumn_parent();
      case PREDICATE:
        return isSetPredicate();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiget_slice_args)
        return this.equals((multiget_slice_args)that);
      return false;
    }

    public boolean equals(multiget_slice_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_keys = true && this.isSetKeys();
      boolean that_present_keys = true && that.isSetKeys();
      if (this_present_keys || that_present_keys) {
        if (!(this_present_keys && that_present_keys))
          return false;
        if (!this.keys.equals(that.keys))
          return false;
      }

      boolean this_present_column_parent = true && this.isSetColumn_parent();
      boolean that_present_column_parent = true && that.isSetColumn_parent();
      if (this_present_column_parent || that_present_column_parent) {
        if (!(this_present_column_parent && that_present_column_parent))
          return false;
        if (!this.column_parent.equals(that.column_parent))
          return false;
      }

      boolean this_present_predicate = true && this.isSetPredicate();
      boolean that_present_predicate = true && that.isSetPredicate();
      if (this_present_predicate || that_present_predicate) {
        if (!(this_present_predicate && that_present_predicate))
          return false;
        if (!this.predicate.equals(that.predicate))
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(multiget_slice_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      multiget_slice_args typedOther = (multiget_slice_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetKeys()).compareTo(isSetKeys());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(isSetPredicate());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEYS:
            if (field.type == TType.LIST) {
              {
                TList _list21 = iprot.readListBegin();
                this.keys = new ArrayList<String>(_list21.size);
                for (int _i22 = 0; _i22 < _list21.size; ++_i22)
                {
                  String _elem23;
                  _elem23 = iprot.readString();
                  this.keys.add(_elem23);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PARENT:
            if (field.type == TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case PREDICATE:
            if (field.type == TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.keys != null) {
        oprot.writeFieldBegin(KEYS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
          for (String _iter24 : this.keys)
          {
            oprot.writeString(_iter24);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.column_parent != null) {
        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
        this.column_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.predicate != null) {
        oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
        this.predicate.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiget_slice_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("keys:");
      if (this.keys == null) {
        sb.append("null");
      } else {
        sb.append(this.keys);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_parent:");
      if (this.column_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_parent);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("predicate:");
      if (this.predicate == null) {
        sb.append("null");
      } else {
        sb.append(this.predicate);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (keys == null) {
        throw new TProtocolException("Required field 'keys' was not present! Struct: " + toString());
      }
      if (column_parent == null) {
        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
      }
      if (predicate == null) {
        throw new TProtocolException("Required field 'predicate' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class multiget_slice_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public Map<String,List<ColumnOrSuperColumn>> success;
    public InvalidRequestException ire;
    public UnavailableException ue;
    public static final int SUCCESS = 0;
    public static final int IRE = 1;
    public static final int UE = 2;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new ListMetaData(TType.LIST, 
                  new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(multiget_slice_result.class, metaDataMap);
    }

    public multiget_slice_result() {
    }

    public multiget_slice_result(
      Map<String,List<ColumnOrSuperColumn>> success,
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public multiget_slice_result(multiget_slice_result other) {
      if (other.isSetSuccess()) {
        Map<String,List<ColumnOrSuperColumn>> __this__success = new HashMap<String,List<ColumnOrSuperColumn>>();
        for (Map.Entry<String, List<ColumnOrSuperColumn>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          List<ColumnOrSuperColumn> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          List<ColumnOrSuperColumn> __this__success_copy_value = new ArrayList<ColumnOrSuperColumn>();
          for (ColumnOrSuperColumn other_element_value_element : other_element_value) {
            __this__success_copy_value.add(new ColumnOrSuperColumn(other_element_value_element));
          }

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public multiget_slice_result deepCopy() {
      return new multiget_slice_result(this);
    }

    @Deprecated
    public multiget_slice_result clone() {
      return new multiget_slice_result(this);
    }

    public Map<String,List<ColumnOrSuperColumn>> getSuccess() {
      return this.success;
    }

    public multiget_slice_result setSuccess(Map<String,List<ColumnOrSuperColumn>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public multiget_slice_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public multiget_slice_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,List<ColumnOrSuperColumn>>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof multiget_slice_result)
        return this.equals((multiget_slice_result)that);
      return false;
    }

    public boolean equals(multiget_slice_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.MAP) {
              {
                TMap _map25 = iprot.readMapBegin();
                this.success = new HashMap<String,List<ColumnOrSuperColumn>>(2*_map25.size);
                for (int _i26 = 0; _i26 < _map25.size; ++_i26)
                {
                  String _key27;
                  List<ColumnOrSuperColumn> _val28;
                  _key27 = iprot.readString();
                  {
                    TList _list29 = iprot.readListBegin();
                    _val28 = new ArrayList<ColumnOrSuperColumn>(_list29.size);
                    for (int _i30 = 0; _i30 < _list29.size; ++_i30)
                    {
                      ColumnOrSuperColumn _elem31;
                      _elem31 = new ColumnOrSuperColumn();
                      _elem31.read(iprot);
                      _val28.add(_elem31);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key27, _val28);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
          for (Map.Entry<String, List<ColumnOrSuperColumn>> _iter32 : this.success.entrySet())
          {
            oprot.writeString(_iter32.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRUCT, _iter32.getValue().size()));
              for (ColumnOrSuperColumn _iter33 : _iter32.getValue())
              {
                _iter33.write(oprot);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("multiget_slice_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_count_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_count_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)3);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);

    public String keyspace;
    public String key;
    public ColumnParent column_parent;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEY = 2;
    public static final int COLUMN_PARENT = 3;
    public static final int CONSISTENCY_LEVEL = 4;

    // isset id assignments
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnParent.class)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_count_args.class, metaDataMap);
    }

    public get_count_args() {
      this.consistency_level = 1;

    }

    public get_count_args(
      String keyspace,
      String key,
      ColumnParent column_parent,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.key = key;
      this.column_parent = column_parent;
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_count_args(get_count_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_parent()) {
        this.column_parent = new ColumnParent(other.column_parent);
      }
      this.consistency_level = other.consistency_level;
    }

    public get_count_args deepCopy() {
      return new get_count_args(this);
    }

    @Deprecated
    public get_count_args clone() {
      return new get_count_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public get_count_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public get_count_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnParent getColumn_parent() {
      return this.column_parent;
    }

    public get_count_args setColumn_parent(ColumnParent column_parent) {
      this.column_parent = column_parent;
      return this;
    }

    public void unsetColumn_parent() {
      this.column_parent = null;
    }

    // Returns true if field column_parent is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_parent() {
      return this.column_parent != null;
    }

    public void setColumn_parentIsSet(boolean value) {
      if (!value) {
        this.column_parent = null;
      }
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public get_count_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PARENT:
        if (value == null) {
          unsetColumn_parent();
        } else {
          setColumn_parent((ColumnParent)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEY:
        return getKey();

      case COLUMN_PARENT:
        return getColumn_parent();

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEY:
        return isSetKey();
      case COLUMN_PARENT:
        return isSetColumn_parent();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_count_args)
        return this.equals((get_count_args)that);
      return false;
    }

    public boolean equals(get_count_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_parent = true && this.isSetColumn_parent();
      boolean that_present_column_parent = true && that.isSetColumn_parent();
      if (this_present_column_parent || that_present_column_parent) {
        if (!(this_present_column_parent && that_present_column_parent))
          return false;
        if (!this.column_parent.equals(that.column_parent))
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_count_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_count_args typedOther = (get_count_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(isSetColumn_parent());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PARENT:
            if (field.type == TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_parent != null) {
        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
        this.column_parent.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_count_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_parent:");
      if (this.column_parent == null) {
        sb.append("null");
      } else {
        sb.append(this.column_parent);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (key == null) {
        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
      }
      if (column_parent == null) {
        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class get_count_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_count_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_count_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public int success;
    public InvalidRequestException ire;
    public UnavailableException ue;
    public static final int SUCCESS = 0;
    public static final int IRE = 1;
    public static final int UE = 2;

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_count_result.class, metaDataMap);
    }

    public get_count_result() {
    }

    public get_count_result(
      int success,
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_count_result(get_count_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public get_count_result deepCopy() {
      return new get_count_result(this);
    }

    @Deprecated
    public get_count_result clone() {
      return new get_count_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public get_count_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public get_count_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public get_count_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Integer(getSuccess());

      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_count_result)
        return this.equals((get_count_result)that);
      return false;
    }

    public boolean equals(get_count_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_count_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_count_result typedOther = (get_count_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_count_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_key_range_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_key_range_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_key_range_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("column_family", TType.STRING, (short)2);
    private static final TField START_FIELD_DESC = new TField("start", TType.STRING, (short)3);
    private static final TField FINISH_FIELD_DESC = new TField("finish", TType.STRING, (short)4);
    private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)5);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)6);

    public String keyspace;
    public String column_family;
    public String start;
    public String finish;
    public int count;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int COLUMN_FAMILY = 2;
    public static final int START = 3;
    public static final int FINISH = 4;
    public static final int COUNT = 5;
    public static final int CONSISTENCY_LEVEL = 6;

    // isset id assignments
    private static final int __COUNT_ISSET_ID = 0;
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_FAMILY, new FieldMetaData("column_family", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(START, new FieldMetaData("start", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(FINISH, new FieldMetaData("finish", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(COUNT, new FieldMetaData("count", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_key_range_args.class, metaDataMap);
    }

    public get_key_range_args() {
      this.start = "";

      this.finish = "";

      this.count = 100;

      this.consistency_level = 1;

    }

    public get_key_range_args(
      String keyspace,
      String column_family,
      String start,
      String finish,
      int count,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.column_family = column_family;
      this.start = start;
      this.finish = finish;
      this.count = count;
      setCountIsSet(true);
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_key_range_args(get_key_range_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetColumn_family()) {
        this.column_family = other.column_family;
      }
      if (other.isSetStart()) {
        this.start = other.start;
      }
      if (other.isSetFinish()) {
        this.finish = other.finish;
      }
      this.count = other.count;
      this.consistency_level = other.consistency_level;
    }

    public get_key_range_args deepCopy() {
      return new get_key_range_args(this);
    }

    @Deprecated
    public get_key_range_args clone() {
      return new get_key_range_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public get_key_range_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public String getColumn_family() {
      return this.column_family;
    }

    public get_key_range_args setColumn_family(String column_family) {
      this.column_family = column_family;
      return this;
    }

    public void unsetColumn_family() {
      this.column_family = null;
    }

    // Returns true if field column_family is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_family() {
      return this.column_family != null;
    }

    public void setColumn_familyIsSet(boolean value) {
      if (!value) {
        this.column_family = null;
      }
    }

    public String getStart() {
      return this.start;
    }

    public get_key_range_args setStart(String start) {
      this.start = start;
      return this;
    }

    public void unsetStart() {
      this.start = null;
    }

    // Returns true if field start is set (has been asigned a value) and false otherwise
    public boolean isSetStart() {
      return this.start != null;
    }

    public void setStartIsSet(boolean value) {
      if (!value) {
        this.start = null;
      }
    }

    public String getFinish() {
      return this.finish;
    }

    public get_key_range_args setFinish(String finish) {
      this.finish = finish;
      return this;
    }

    public void unsetFinish() {
      this.finish = null;
    }

    // Returns true if field finish is set (has been asigned a value) and false otherwise
    public boolean isSetFinish() {
      return this.finish != null;
    }

    public void setFinishIsSet(boolean value) {
      if (!value) {
        this.finish = null;
      }
    }

    public int getCount() {
      return this.count;
    }

    public get_key_range_args setCount(int count) {
      this.count = count;
      setCountIsSet(true);
      return this;
    }

    public void unsetCount() {
      __isset_bit_vector.clear(__COUNT_ISSET_ID);
    }

    // Returns true if field count is set (has been asigned a value) and false otherwise
    public boolean isSetCount() {
      return __isset_bit_vector.get(__COUNT_ISSET_ID);
    }

    public void setCountIsSet(boolean value) {
      __isset_bit_vector.set(__COUNT_ISSET_ID, value);
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public get_key_range_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case COLUMN_FAMILY:
        if (value == null) {
          unsetColumn_family();
        } else {
          setColumn_family((String)value);
        }
        break;

      case START:
        if (value == null) {
          unsetStart();
        } else {
          setStart((String)value);
        }
        break;

      case FINISH:
        if (value == null) {
          unsetFinish();
        } else {
          setFinish((String)value);
        }
        break;

      case COUNT:
        if (value == null) {
          unsetCount();
        } else {
          setCount((Integer)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case COLUMN_FAMILY:
        return getColumn_family();

      case START:
        return getStart();

      case FINISH:
        return getFinish();

      case COUNT:
        return new Integer(getCount());

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case COLUMN_FAMILY:
        return isSetColumn_family();
      case START:
        return isSetStart();
      case FINISH:
        return isSetFinish();
      case COUNT:
        return isSetCount();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_key_range_args)
        return this.equals((get_key_range_args)that);
      return false;
    }

    public boolean equals(get_key_range_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_column_family = true && this.isSetColumn_family();
      boolean that_present_column_family = true && that.isSetColumn_family();
      if (this_present_column_family || that_present_column_family) {
        if (!(this_present_column_family && that_present_column_family))
          return false;
        if (!this.column_family.equals(that.column_family))
          return false;
      }

      boolean this_present_start = true && this.isSetStart();
      boolean that_present_start = true && that.isSetStart();
      if (this_present_start || that_present_start) {
        if (!(this_present_start && that_present_start))
          return false;
        if (!this.start.equals(that.start))
          return false;
      }

      boolean this_present_finish = true && this.isSetFinish();
      boolean that_present_finish = true && that.isSetFinish();
      if (this_present_finish || that_present_finish) {
        if (!(this_present_finish && that_present_finish))
          return false;
        if (!this.finish.equals(that.finish))
          return false;
      }

      boolean this_present_count = true;
      boolean that_present_count = true;
      if (this_present_count || that_present_count) {
        if (!(this_present_count && that_present_count))
          return false;
        if (this.count != that.count)
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_key_range_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_key_range_args typedOther = (get_key_range_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_family()).compareTo(isSetColumn_family());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_family, typedOther.column_family);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetStart()).compareTo(isSetStart());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(start, typedOther.start);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetFinish()).compareTo(isSetFinish());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(finish, typedOther.finish);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetCount()).compareTo(isSetCount());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(count, typedOther.count);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_FAMILY:
            if (field.type == TType.STRING) {
              this.column_family = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START:
            if (field.type == TType.STRING) {
              this.start = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case FINISH:
            if (field.type == TType.STRING) {
              this.finish = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COUNT:
            if (field.type == TType.I32) {
              this.count = iprot.readI32();
              setCountIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetCount()) {
        throw new TProtocolException("Required field 'count' was not found in serialized data! Struct: " + toString());
      }
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.column_family != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
        oprot.writeString(this.column_family);
        oprot.writeFieldEnd();
      }
      if (this.start != null) {
        oprot.writeFieldBegin(START_FIELD_DESC);
        oprot.writeString(this.start);
        oprot.writeFieldEnd();
      }
      if (this.finish != null) {
        oprot.writeFieldBegin(FINISH_FIELD_DESC);
        oprot.writeString(this.finish);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(COUNT_FIELD_DESC);
      oprot.writeI32(this.count);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_key_range_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_family:");
      if (this.column_family == null) {
        sb.append("null");
      } else {
        sb.append(this.column_family);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("start:");
      if (this.start == null) {
        sb.append("null");
      } else {
        sb.append(this.start);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("finish:");
      if (this.finish == null) {
        sb.append("null");
      } else {
        sb.append(this.finish);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("count:");
      sb.append(this.count);
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (column_family == null) {
        throw new TProtocolException("Required field 'column_family' was not present! Struct: " + toString());
      }
      if (start == null) {
        throw new TProtocolException("Required field 'start' was not present! Struct: " + toString());
      }
      if (finish == null) {
        throw new TProtocolException("Required field 'finish' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'count' because it's a primitive and you chose the non-beans generator.
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class get_key_range_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_key_range_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_key_range_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public List<String> success;
    public InvalidRequestException ire;
    public UnavailableException ue;
    public static final int SUCCESS = 0;
    public static final int IRE = 1;
    public static final int UE = 2;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_key_range_result.class, metaDataMap);
    }

    public get_key_range_result() {
    }

    public get_key_range_result(
      List<String> success,
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.success = success;
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_key_range_result(get_key_range_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public get_key_range_result deepCopy() {
      return new get_key_range_result(this);
    }

    @Deprecated
    public get_key_range_result clone() {
      return new get_key_range_result(this);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public get_key_range_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public get_key_range_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public get_key_range_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_key_range_result)
        return this.equals((get_key_range_result)that);
      return false;
    }

    public boolean equals(get_key_range_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_key_range_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_key_range_result typedOther = (get_key_range_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list34 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list34.size);
                for (int _i35 = 0; _i35 < _list34.size; ++_i35)
                {
                  String _elem36;
                  _elem36 = iprot.readString();
                  this.success.add(_elem36);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter37 : this.success)
          {
            oprot.writeString(_iter37);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_key_range_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class insert_args implements TBase, java.io.Serializable, Cloneable, Comparable<insert_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("insert_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)4);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)5);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)6);

    public String keyspace;
    public String key;
    public ColumnPath column_path;
    public byte[] value;
    public long timestamp;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEY = 2;
    public static final int COLUMN_PATH = 3;
    public static final int VALUE = 4;
    public static final int TIMESTAMP = 5;
    public static final int CONSISTENCY_LEVEL = 6;

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnPath.class)));
      put(VALUE, new FieldMetaData("value", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I64)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(insert_args.class, metaDataMap);
    }

    public insert_args() {
      this.consistency_level = 0;

    }

    public insert_args(
      String keyspace,
      String key,
      ColumnPath column_path,
      byte[] value,
      long timestamp,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.key = key;
      this.column_path = column_path;
      this.value = value;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public insert_args(insert_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_path()) {
        this.column_path = new ColumnPath(other.column_path);
      }
      if (other.isSetValue()) {
        this.value = new byte[other.value.length];
        System.arraycopy(other.value, 0, value, 0, other.value.length);
      }
      this.timestamp = other.timestamp;
      this.consistency_level = other.consistency_level;
    }

    public insert_args deepCopy() {
      return new insert_args(this);
    }

    @Deprecated
    public insert_args clone() {
      return new insert_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public insert_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public insert_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnPath getColumn_path() {
      return this.column_path;
    }

    public insert_args setColumn_path(ColumnPath column_path) {
      this.column_path = column_path;
      return this;
    }

    public void unsetColumn_path() {
      this.column_path = null;
    }

    // Returns true if field column_path is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path() {
      return this.column_path != null;
    }

    public void setColumn_pathIsSet(boolean value) {
      if (!value) {
        this.column_path = null;
      }
    }

    public byte[] getValue() {
      return this.value;
    }

    public insert_args setValue(byte[] value) {
      this.value = value;
      return this;
    }

    public void unsetValue() {
      this.value = null;
    }

    // Returns true if field value is set (has been asigned a value) and false otherwise
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public insert_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    // Returns true if field timestamp is set (has been asigned a value) and false otherwise
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public insert_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PATH:
        if (value == null) {
          unsetColumn_path();
        } else {
          setColumn_path((ColumnPath)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((byte[])value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEY:
        return getKey();

      case COLUMN_PATH:
        return getColumn_path();

      case VALUE:
        return getValue();

      case TIMESTAMP:
        return new Long(getTimestamp());

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEY:
        return isSetKey();
      case COLUMN_PATH:
        return isSetColumn_path();
      case VALUE:
        return isSetValue();
      case TIMESTAMP:
        return isSetTimestamp();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof insert_args)
        return this.equals((insert_args)that);
      return false;
    }

    public boolean equals(insert_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_path = true && this.isSetColumn_path();
      boolean that_present_column_path = true && that.isSetColumn_path();
      if (this_present_column_path || that_present_column_path) {
        if (!(this_present_column_path && that_present_column_path))
          return false;
        if (!this.column_path.equals(that.column_path))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!java.util.Arrays.equals(this.value, that.value))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(insert_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      insert_args typedOther = (insert_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetValue()).compareTo(isSetValue());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(value, typedOther.value);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PATH:
            if (field.type == TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case VALUE:
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMESTAMP:
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetTimestamp()) {
        throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
      }
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_path != null) {
        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
        this.column_path.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("insert_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_path:");
      if (this.column_path == null) {
        sb.append("null");
      } else {
        sb.append(this.column_path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
          int __value_size = Math.min(this.value.length, 128);
          for (int i = 0; i < __value_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
          }
          if (this.value.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (key == null) {
        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
      }
      if (column_path == null) {
        throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
      }
      if (value == null) {
        throw new TProtocolException("Required field 'value' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class insert_result implements TBase, java.io.Serializable, Cloneable, Comparable<insert_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("insert_result");
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public InvalidRequestException ire;
    public UnavailableException ue;
    public static final int IRE = 1;
    public static final int UE = 2;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(insert_result.class, metaDataMap);
    }

    public insert_result() {
    }

    public insert_result(
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public insert_result(insert_result other) {
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public insert_result deepCopy() {
      return new insert_result(this);
    }

    @Deprecated
    public insert_result clone() {
      return new insert_result(this);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public insert_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public insert_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof insert_result)
        return this.equals((insert_result)that);
      return false;
    }

    public boolean equals(insert_result that) {
      if (that == null)
        return false;

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(insert_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      insert_result typedOther = (insert_result)other;

      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("insert_result(");
      boolean first = true;

      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField CFMAP_FIELD_DESC = new TField("cfmap", TType.MAP, (short)3);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);

    public String keyspace;
    public String key;
    public Map<String,List<ColumnOrSuperColumn>> cfmap;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEY = 2;
    public static final int CFMAP = 3;
    public static final int CONSISTENCY_LEVEL = 4;

    // isset id assignments
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(CFMAP, new FieldMetaData("cfmap", TFieldRequirementType.REQUIRED, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new ListMetaData(TType.LIST, 
                  new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)))));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_args.class, metaDataMap);
    }

    public batch_insert_args() {
      this.consistency_level = 0;

    }

    public batch_insert_args(
      String keyspace,
      String key,
      Map<String,List<ColumnOrSuperColumn>> cfmap,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.key = key;
      this.cfmap = cfmap;
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_args(batch_insert_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetCfmap()) {
        Map<String,List<ColumnOrSuperColumn>> __this__cfmap = new HashMap<String,List<ColumnOrSuperColumn>>();
        for (Map.Entry<String, List<ColumnOrSuperColumn>> other_element : other.cfmap.entrySet()) {

          String other_element_key = other_element.getKey();
          List<ColumnOrSuperColumn> other_element_value = other_element.getValue();

          String __this__cfmap_copy_key = other_element_key;

          List<ColumnOrSuperColumn> __this__cfmap_copy_value = new ArrayList<ColumnOrSuperColumn>();
          for (ColumnOrSuperColumn other_element_value_element : other_element_value) {
            __this__cfmap_copy_value.add(new ColumnOrSuperColumn(other_element_value_element));
          }

          __this__cfmap.put(__this__cfmap_copy_key, __this__cfmap_copy_value);
        }
        this.cfmap = __this__cfmap;
      }
      this.consistency_level = other.consistency_level;
    }

    public batch_insert_args deepCopy() {
      return new batch_insert_args(this);
    }

    @Deprecated
    public batch_insert_args clone() {
      return new batch_insert_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public batch_insert_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public batch_insert_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public Map<String,List<ColumnOrSuperColumn>> getCfmap() {
      return this.cfmap;
    }

    public batch_insert_args setCfmap(Map<String,List<ColumnOrSuperColumn>> cfmap) {
      this.cfmap = cfmap;
      return this;
    }

    public void unsetCfmap() {
      this.cfmap = null;
    }

    // Returns true if field cfmap is set (has been asigned a value) and false otherwise
    public boolean isSetCfmap() {
      return this.cfmap != null;
    }

    public void setCfmapIsSet(boolean value) {
      if (!value) {
        this.cfmap = null;
      }
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public batch_insert_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case CFMAP:
        if (value == null) {
          unsetCfmap();
        } else {
          setCfmap((Map<String,List<ColumnOrSuperColumn>>)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEY:
        return getKey();

      case CFMAP:
        return getCfmap();

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEY:
        return isSetKey();
      case CFMAP:
        return isSetCfmap();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_args)
        return this.equals((batch_insert_args)that);
      return false;
    }

    public boolean equals(batch_insert_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_cfmap = true && this.isSetCfmap();
      boolean that_present_cfmap = true && that.isSetCfmap();
      if (this_present_cfmap || that_present_cfmap) {
        if (!(this_present_cfmap && that_present_cfmap))
          return false;
        if (!this.cfmap.equals(that.cfmap))
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CFMAP:
            if (field.type == TType.MAP) {
              {
                TMap _map38 = iprot.readMapBegin();
                this.cfmap = new HashMap<String,List<ColumnOrSuperColumn>>(2*_map38.size);
                for (int _i39 = 0; _i39 < _map38.size; ++_i39)
                {
                  String _key40;
                  List<ColumnOrSuperColumn> _val41;
                  _key40 = iprot.readString();
                  {
                    TList _list42 = iprot.readListBegin();
                    _val41 = new ArrayList<ColumnOrSuperColumn>(_list42.size);
                    for (int _i43 = 0; _i43 < _list42.size; ++_i43)
                    {
                      ColumnOrSuperColumn _elem44;
                      _elem44 = new ColumnOrSuperColumn();
                      _elem44.read(iprot);
                      _val41.add(_elem44);
                    }
                    iprot.readListEnd();
                  }
                  this.cfmap.put(_key40, _val41);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetConsistency_level()) {
        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.cfmap != null) {
        oprot.writeFieldBegin(CFMAP_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.cfmap.size()));
          for (Map.Entry<String, List<ColumnOrSuperColumn>> _iter45 : this.cfmap.entrySet())
          {
            oprot.writeString(_iter45.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRUCT, _iter45.getValue().size()));
              for (ColumnOrSuperColumn _iter46 : _iter45.getValue())
              {
                _iter46.write(oprot);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cfmap:");
      if (this.cfmap == null) {
        sb.append("null");
      } else {
        sb.append(this.cfmap);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (key == null) {
        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
      }
      if (cfmap == null) {
        throw new TProtocolException("Required field 'cfmap' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class batch_insert_result implements TBase, java.io.Serializable, Cloneable, Comparable<batch_insert_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_result");
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public InvalidRequestException ire;
    public UnavailableException ue;
    public static final int IRE = 1;
    public static final int UE = 2;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_result.class, metaDataMap);
    }

    public batch_insert_result() {
    }

    public batch_insert_result(
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_result(batch_insert_result other) {
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public batch_insert_result deepCopy() {
      return new batch_insert_result(this);
    }

    @Deprecated
    public batch_insert_result clone() {
      return new batch_insert_result(this);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public batch_insert_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public batch_insert_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_result)
        return this.equals((batch_insert_result)that);
      return false;
    }

    public boolean equals(batch_insert_result that) {
      if (that == null)
        return false;

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(batch_insert_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      batch_insert_result typedOther = (batch_insert_result)other;

      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_result(");
      boolean first = true;

      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable, Comparable<remove_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);
    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);

    public String keyspace;
    public String key;
    public ColumnPath column_path;
    public long timestamp;
    /**
     * 
     * @see ConsistencyLevel
     */
    public int consistency_level;
    public static final int KEYSPACE = 1;
    public static final int KEY = 2;
    public static final int COLUMN_PATH = 3;
    public static final int TIMESTAMP = 4;
    public static final int CONSISTENCY_LEVEL = 5;

    // isset id assignments
    private static final int __TIMESTAMP_ISSET_ID = 0;
    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
          new StructMetaData(TType.STRUCT, ColumnPath.class)));
      put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.I64)));
      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
      this.consistency_level = 0;

    }

    public remove_args(
      String keyspace,
      String key,
      ColumnPath column_path,
      long timestamp,
      int consistency_level)
    {
      this();
      this.keyspace = keyspace;
      this.key = key;
      this.column_path = column_path;
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetColumn_path()) {
        this.column_path = new ColumnPath(other.column_path);
      }
      this.timestamp = other.timestamp;
      this.consistency_level = other.consistency_level;
    }

    public remove_args deepCopy() {
      return new remove_args(this);
    }

    @Deprecated
    public remove_args clone() {
      return new remove_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public remove_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public remove_args setKey(String key) {
      this.key = key;
      return this;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public ColumnPath getColumn_path() {
      return this.column_path;
    }

    public remove_args setColumn_path(ColumnPath column_path) {
      this.column_path = column_path;
      return this;
    }

    public void unsetColumn_path() {
      this.column_path = null;
    }

    // Returns true if field column_path is set (has been asigned a value) and false otherwise
    public boolean isSetColumn_path() {
      return this.column_path != null;
    }

    public void setColumn_pathIsSet(boolean value) {
      if (!value) {
        this.column_path = null;
      }
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public remove_args setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      setTimestampIsSet(true);
      return this;
    }

    public void unsetTimestamp() {
      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
    }

    // Returns true if field timestamp is set (has been asigned a value) and false otherwise
    public boolean isSetTimestamp() {
      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
    }

    public void setTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public int getConsistency_level() {
      return this.consistency_level;
    }

    /**
     * 
     * @see ConsistencyLevel
     */
    public remove_args setConsistency_level(int consistency_level) {
      this.consistency_level = consistency_level;
      setConsistency_levelIsSet(true);
      return this;
    }

    public void unsetConsistency_level() {
      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
    public boolean isSetConsistency_level() {
      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
    }

    public void setConsistency_levelIsSet(boolean value) {
      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case COLUMN_PATH:
        if (value == null) {
          unsetColumn_path();
        } else {
          setColumn_path((ColumnPath)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((Long)value);
        }
        break;

      case CONSISTENCY_LEVEL:
        if (value == null) {
          unsetConsistency_level();
        } else {
          setConsistency_level((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      case KEY:
        return getKey();

      case COLUMN_PATH:
        return getColumn_path();

      case TIMESTAMP:
        return new Long(getTimestamp());

      case CONSISTENCY_LEVEL:
        return getConsistency_level();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      case KEY:
        return isSetKey();
      case COLUMN_PATH:
        return isSetColumn_path();
      case TIMESTAMP:
        return isSetTimestamp();
      case CONSISTENCY_LEVEL:
        return isSetConsistency_level();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_column_path = true && this.isSetColumn_path();
      boolean that_present_column_path = true && that.isSetColumn_path();
      if (this_present_column_path || that_present_column_path) {
        if (!(this_present_column_path && that_present_column_path))
          return false;
        if (!this.column_path.equals(that.column_path))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      boolean this_present_consistency_level = true;
      boolean that_present_consistency_level = true;
      if (this_present_consistency_level || that_present_consistency_level) {
        if (!(this_present_consistency_level && that_present_consistency_level))
          return false;
        if (this.consistency_level != that.consistency_level)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(remove_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      remove_args typedOther = (remove_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetKey()).compareTo(isSetKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumn_path()).compareTo(isSetColumn_path());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(column_path, typedOther.column_path);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(isSetConsistency_level());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMN_PATH:
            if (field.type == TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMESTAMP:
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CONSISTENCY_LEVEL:
            if (field.type == TType.I32) {
              this.consistency_level = iprot.readI32();
              setConsistency_levelIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetTimestamp()) {
        throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
      }
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.column_path != null) {
        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
        this.column_path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
      oprot.writeI32(this.consistency_level);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("column_path:");
      if (this.column_path == null) {
        sb.append("null");
      } else {
        sb.append(this.column_path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      if (!first) sb.append(", ");
      sb.append("consistency_level:");
      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(consistency_level_name);
        sb.append(" (");
      }
      sb.append(this.consistency_level);
      if (consistency_level_name != null) {
        sb.append(")");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      if (key == null) {
        throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
      }
      if (column_path == null) {
        throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
      // check that fields of type enum have valid values
      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
      }
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable, Comparable<remove_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);

    public InvalidRequestException ire;
    public UnavailableException ue;
    public static final int IRE = 1;
    public static final int UE = 2;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      InvalidRequestException ire,
      UnavailableException ue)
    {
      this();
      this.ire = ire;
      this.ue = ue;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetIre()) {
        this.ire = new InvalidRequestException(other.ire);
      }
      if (other.isSetUe()) {
        this.ue = new UnavailableException(other.ue);
      }
    }

    public remove_result deepCopy() {
      return new remove_result(this);
    }

    @Deprecated
    public remove_result clone() {
      return new remove_result(this);
    }

    public InvalidRequestException getIre() {
      return this.ire;
    }

    public remove_result setIre(InvalidRequestException ire) {
      this.ire = ire;
      return this;
    }

    public void unsetIre() {
      this.ire = null;
    }

    // Returns true if field ire is set (has been asigned a value) and false otherwise
    public boolean isSetIre() {
      return this.ire != null;
    }

    public void setIreIsSet(boolean value) {
      if (!value) {
        this.ire = null;
      }
    }

    public UnavailableException getUe() {
      return this.ue;
    }

    public remove_result setUe(UnavailableException ue) {
      this.ue = ue;
      return this;
    }

    public void unsetUe() {
      this.ue = null;
    }

    // Returns true if field ue is set (has been asigned a value) and false otherwise
    public boolean isSetUe() {
      return this.ue != null;
    }

    public void setUeIsSet(boolean value) {
      if (!value) {
        this.ue = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case IRE:
        if (value == null) {
          unsetIre();
        } else {
          setIre((InvalidRequestException)value);
        }
        break;

      case UE:
        if (value == null) {
          unsetUe();
        } else {
          setUe((UnavailableException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case IRE:
        return getIre();

      case UE:
        return getUe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case IRE:
        return isSetIre();
      case UE:
        return isSetUe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;

      boolean this_present_ire = true && this.isSetIre();
      boolean that_present_ire = true && that.isSetIre();
      if (this_present_ire || that_present_ire) {
        if (!(this_present_ire && that_present_ire))
          return false;
        if (!this.ire.equals(that.ire))
          return false;
      }

      boolean this_present_ue = true && this.isSetUe();
      boolean that_present_ue = true && that.isSetUe();
      if (this_present_ue || that_present_ue) {
        if (!(this_present_ue && that_present_ue))
          return false;
        if (!this.ue.equals(that.ue))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(remove_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      remove_result typedOther = (remove_result)other;

      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case IRE:
            if (field.type == TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case UE:
            if (field.type == TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetUe()) {
        oprot.writeFieldBegin(UE_FIELD_DESC);
        this.ue.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_result(");
      boolean first = true;

      sb.append("ire:");
      if (this.ire == null) {
        sb.append("null");
      } else {
        sb.append(this.ire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ue:");
      if (this.ue == null) {
        sb.append("null");
      } else {
        sb.append(this.ue);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_string_property_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_property_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_string_property_args");
    private static final TField PROPERTY_FIELD_DESC = new TField("property", TType.STRING, (short)1);

    public String property;
    public static final int PROPERTY = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTY, new FieldMetaData("property", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_string_property_args.class, metaDataMap);
    }

    public get_string_property_args() {
    }

    public get_string_property_args(
      String property)
    {
      this();
      this.property = property;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_string_property_args(get_string_property_args other) {
      if (other.isSetProperty()) {
        this.property = other.property;
      }
    }

    public get_string_property_args deepCopy() {
      return new get_string_property_args(this);
    }

    @Deprecated
    public get_string_property_args clone() {
      return new get_string_property_args(this);
    }

    public String getProperty() {
      return this.property;
    }

    public get_string_property_args setProperty(String property) {
      this.property = property;
      return this;
    }

    public void unsetProperty() {
      this.property = null;
    }

    // Returns true if field property is set (has been asigned a value) and false otherwise
    public boolean isSetProperty() {
      return this.property != null;
    }

    public void setPropertyIsSet(boolean value) {
      if (!value) {
        this.property = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PROPERTY:
        if (value == null) {
          unsetProperty();
        } else {
          setProperty((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PROPERTY:
        return getProperty();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PROPERTY:
        return isSetProperty();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_string_property_args)
        return this.equals((get_string_property_args)that);
      return false;
    }

    public boolean equals(get_string_property_args that) {
      if (that == null)
        return false;

      boolean this_present_property = true && this.isSetProperty();
      boolean that_present_property = true && that.isSetProperty();
      if (this_present_property || that_present_property) {
        if (!(this_present_property && that_present_property))
          return false;
        if (!this.property.equals(that.property))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_string_property_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_string_property_args typedOther = (get_string_property_args)other;

      lastComparison = Boolean.valueOf(isSetProperty()).compareTo(isSetProperty());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(property, typedOther.property);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PROPERTY:
            if (field.type == TType.STRING) {
              this.property = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.property != null) {
        oprot.writeFieldBegin(PROPERTY_FIELD_DESC);
        oprot.writeString(this.property);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_string_property_args(");
      boolean first = true;

      sb.append("property:");
      if (this.property == null) {
        sb.append("null");
      } else {
        sb.append(this.property);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (property == null) {
        throw new TProtocolException("Required field 'property' was not present! Struct: " + toString());
      }
      // check that fields of type enum have valid values
    }

  }

  public static class get_string_property_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_property_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_string_property_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_string_property_result.class, metaDataMap);
    }

    public get_string_property_result() {
    }

    public get_string_property_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_string_property_result(get_string_property_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public get_string_property_result deepCopy() {
      return new get_string_property_result(this);
    }

    @Deprecated
    public get_string_property_result clone() {
      return new get_string_property_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public get_string_property_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_string_property_result)
        return this.equals((get_string_property_result)that);
      return false;
    }

    public boolean equals(get_string_property_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_string_property_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_string_property_result typedOther = (get_string_property_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_string_property_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_string_list_property_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_list_property_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_string_list_property_args");
    private static final TField PROPERTY_FIELD_DESC = new TField("property", TType.STRING, (short)1);

    public String property;
    public static final int PROPERTY = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTY, new FieldMetaData("property", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_string_list_property_args.class, metaDataMap);
    }

    public get_string_list_property_args() {
    }

    public get_string_list_property_args(
      String property)
    {
      this();
      this.property = property;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_string_list_property_args(get_string_list_property_args other) {
      if (other.isSetProperty()) {
        this.property = other.property;
      }
    }

    public get_string_list_property_args deepCopy() {
      return new get_string_list_property_args(this);
    }

    @Deprecated
    public get_string_list_property_args clone() {
      return new get_string_list_property_args(this);
    }

    public String getProperty() {
      return this.property;
    }

    public get_string_list_property_args setProperty(String property) {
      this.property = property;
      return this;
    }

    public void unsetProperty() {
      this.property = null;
    }

    // Returns true if field property is set (has been asigned a value) and false otherwise
    public boolean isSetProperty() {
      return this.property != null;
    }

    public void setPropertyIsSet(boolean value) {
      if (!value) {
        this.property = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PROPERTY:
        if (value == null) {
          unsetProperty();
        } else {
          setProperty((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PROPERTY:
        return getProperty();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PROPERTY:
        return isSetProperty();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_string_list_property_args)
        return this.equals((get_string_list_property_args)that);
      return false;
    }

    public boolean equals(get_string_list_property_args that) {
      if (that == null)
        return false;

      boolean this_present_property = true && this.isSetProperty();
      boolean that_present_property = true && that.isSetProperty();
      if (this_present_property || that_present_property) {
        if (!(this_present_property && that_present_property))
          return false;
        if (!this.property.equals(that.property))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_string_list_property_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_string_list_property_args typedOther = (get_string_list_property_args)other;

      lastComparison = Boolean.valueOf(isSetProperty()).compareTo(isSetProperty());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(property, typedOther.property);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PROPERTY:
            if (field.type == TType.STRING) {
              this.property = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.property != null) {
        oprot.writeFieldBegin(PROPERTY_FIELD_DESC);
        oprot.writeString(this.property);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_string_list_property_args(");
      boolean first = true;

      sb.append("property:");
      if (this.property == null) {
        sb.append("null");
      } else {
        sb.append(this.property);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (property == null) {
        throw new TProtocolException("Required field 'property' was not present! Struct: " + toString());
      }
      // check that fields of type enum have valid values
    }

  }

  public static class get_string_list_property_result implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_list_property_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_string_list_property_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_string_list_property_result.class, metaDataMap);
    }

    public get_string_list_property_result() {
    }

    public get_string_list_property_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_string_list_property_result(get_string_list_property_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public get_string_list_property_result deepCopy() {
      return new get_string_list_property_result(this);
    }

    @Deprecated
    public get_string_list_property_result clone() {
      return new get_string_list_property_result(this);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public get_string_list_property_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_string_list_property_result)
        return this.equals((get_string_list_property_result)that);
      return false;
    }

    public boolean equals(get_string_list_property_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_string_list_property_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_string_list_property_result typedOther = (get_string_list_property_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list47 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list47.size);
                for (int _i48 = 0; _i48 < _list47.size; ++_i48)
                {
                  String _elem49;
                  _elem49 = iprot.readString();
                  this.success.add(_elem49);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter50 : this.success)
          {
            oprot.writeString(_iter50);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_string_list_property_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class describe_keyspace_args implements TBase, java.io.Serializable, Cloneable, Comparable<describe_keyspace_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_args");
    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);

    public String keyspace;
    public static final int KEYSPACE = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(describe_keyspace_args.class, metaDataMap);
    }

    public describe_keyspace_args() {
    }

    public describe_keyspace_args(
      String keyspace)
    {
      this();
      this.keyspace = keyspace;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public describe_keyspace_args(describe_keyspace_args other) {
      if (other.isSetKeyspace()) {
        this.keyspace = other.keyspace;
      }
    }

    public describe_keyspace_args deepCopy() {
      return new describe_keyspace_args(this);
    }

    @Deprecated
    public describe_keyspace_args clone() {
      return new describe_keyspace_args(this);
    }

    public String getKeyspace() {
      return this.keyspace;
    }

    public describe_keyspace_args setKeyspace(String keyspace) {
      this.keyspace = keyspace;
      return this;
    }

    public void unsetKeyspace() {
      this.keyspace = null;
    }

    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
    public boolean isSetKeyspace() {
      return this.keyspace != null;
    }

    public void setKeyspaceIsSet(boolean value) {
      if (!value) {
        this.keyspace = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEYSPACE:
        if (value == null) {
          unsetKeyspace();
        } else {
          setKeyspace((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return getKeyspace();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEYSPACE:
        return isSetKeyspace();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof describe_keyspace_args)
        return this.equals((describe_keyspace_args)that);
      return false;
    }

    public boolean equals(describe_keyspace_args that) {
      if (that == null)
        return false;

      boolean this_present_keyspace = true && this.isSetKeyspace();
      boolean that_present_keyspace = true && that.isSetKeyspace();
      if (this_present_keyspace || that_present_keyspace) {
        if (!(this_present_keyspace && that_present_keyspace))
          return false;
        if (!this.keyspace.equals(that.keyspace))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(describe_keyspace_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      describe_keyspace_args typedOther = (describe_keyspace_args)other;

      lastComparison = Boolean.valueOf(isSetKeyspace()).compareTo(isSetKeyspace());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(keyspace, typedOther.keyspace);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEYSPACE:
            if (field.type == TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.keyspace != null) {
        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
        oprot.writeString(this.keyspace);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("describe_keyspace_args(");
      boolean first = true;

      sb.append("keyspace:");
      if (this.keyspace == null) {
        sb.append("null");
      } else {
        sb.append(this.keyspace);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      if (keyspace == null) {
        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
      }
      // check that fields of type enum have valid values
    }

  }

  public static class describe_keyspace_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("describe_keyspace_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)1);

    public Map<String,Map<String,String>> success;
    public NotFoundException nfe;
    public static final int SUCCESS = 0;
    public static final int NFE = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new MapMetaData(TType.MAP, 
                  new FieldValueMetaData(TType.STRING), 
                  new FieldValueMetaData(TType.STRING)))));
      put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(describe_keyspace_result.class, metaDataMap);
    }

    public describe_keyspace_result() {
    }

    public describe_keyspace_result(
      Map<String,Map<String,String>> success,
      NotFoundException nfe)
    {
      this();
      this.success = success;
      this.nfe = nfe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public describe_keyspace_result(describe_keyspace_result other) {
      if (other.isSetSuccess()) {
        Map<String,Map<String,String>> __this__success = new HashMap<String,Map<String,String>>();
        for (Map.Entry<String, Map<String,String>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          Map<String,String> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          Map<String,String> __this__success_copy_value = new HashMap<String,String>();
          for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {

            String other_element_value_element_key = other_element_value_element.getKey();
            String other_element_value_element_value = other_element_value_element.getValue();

            String __this__success_copy_value_copy_key = other_element_value_element_key;

            String __this__success_copy_value_copy_value = other_element_value_element_value;

            __this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
          }

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
      if (other.isSetNfe()) {
        this.nfe = new NotFoundException(other.nfe);
      }
    }

    public describe_keyspace_result deepCopy() {
      return new describe_keyspace_result(this);
    }

    @Deprecated
    public describe_keyspace_result clone() {
      return new describe_keyspace_result(this);
    }

    public Map<String,Map<String,String>> getSuccess() {
      return this.success;
    }

    public describe_keyspace_result setSuccess(Map<String,Map<String,String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public NotFoundException getNfe() {
      return this.nfe;
    }

    public describe_keyspace_result setNfe(NotFoundException nfe) {
      this.nfe = nfe;
      return this;
    }

    public void unsetNfe() {
      this.nfe = null;
    }

    // Returns true if field nfe is set (has been asigned a value) and false otherwise
    public boolean isSetNfe() {
      return this.nfe != null;
    }

    public void setNfeIsSet(boolean value) {
      if (!value) {
        this.nfe = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,Map<String,String>>)value);
        }
        break;

      case NFE:
        if (value == null) {
          unsetNfe();
        } else {
          setNfe((NotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case NFE:
        return getNfe();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case NFE:
        return isSetNfe();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof describe_keyspace_result)
        return this.equals((describe_keyspace_result)that);
      return false;
    }

    public boolean equals(describe_keyspace_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_nfe = true && this.isSetNfe();
      boolean that_present_nfe = true && that.isSetNfe();
      if (this_present_nfe || that_present_nfe) {
        if (!(this_present_nfe && that_present_nfe))
          return false;
        if (!this.nfe.equals(that.nfe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.MAP) {
              {
                TMap _map51 = iprot.readMapBegin();
                this.success = new HashMap<String,Map<String,String>>(2*_map51.size);
                for (int _i52 = 0; _i52 < _map51.size; ++_i52)
                {
                  String _key53;
                  Map<String,String> _val54;
                  _key53 = iprot.readString();
                  {
                    TMap _map55 = iprot.readMapBegin();
                    _val54 = new HashMap<String,String>(2*_map55.size);
                    for (int _i56 = 0; _i56 < _map55.size; ++_i56)
                    {
                      String _key57;
                      String _val58;
                      _key57 = iprot.readString();
                      _val58 = iprot.readString();
                      _val54.put(_key57, _val58);
                    }
                    iprot.readMapEnd();
                  }
                  this.success.put(_key53, _val54);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NFE:
            if (field.type == TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
          for (Map.Entry<String, Map<String,String>> _iter59 : this.success.entrySet())
          {
            oprot.writeString(_iter59.getKey());
            {
              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter59.getValue().size()));
              for (Map.Entry<String, String> _iter60 : _iter59.getValue().entrySet())
              {
                oprot.writeString(_iter60.getKey());
                oprot.writeString(_iter60.getValue());
              }
              oprot.writeMapEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetNfe()) {
        oprot.writeFieldBegin(NFE_FIELD_DESC);
        this.nfe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("describe_keyspace_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("nfe:");
      if (this.nfe == null) {
        sb.append("null");
      } else {
        sb.append(this.nfe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
